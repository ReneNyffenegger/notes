$ Windows Subsystem for Linux (WSL)
@ Windows Subsystem for Linux

WSL was introduced in 2016. It promises to run *unmodified* → Linux binaries in → Windows/versions/10[Windows 10]. (And with
→ https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-14951[Build 14951], it is also possible to run Windows executables
from a WSL distribution).

{ WSL versions

  As of this writing, there are two WSL versions: *WSL 1* and *WSL 2*.

  WSL 2 has the following three features that are not present in WSL 1:
    • Managed VM (Virtual Machine)
    • Full → Linux/kernel[Linux kernel]
    • Full → #wsl-syscall[system calls]
  On the other hand, WSL 2 lacks *Performance across OS file systems*.

  Generally, Microsoft recommends to use WSL 2 if possible. However, accessing the Windows file system from WSL 2 is slower than if accessed from WSL 1.

  The default version can be set (here to 2) with:
code {
c:> → Windows/dirs/Windows/System32/wsl_exe[wsl] --set-default-version 2
code }

}
{ WSLg #wslg

  WSLg is the abbreviation for → https://github.com/microsoft/wslg[Windows Subsystem for Linux GUI]. This component enables GUI applications in WSL. The fundament of WSLg is the *Weston compositor*.

  Audio (in and out) is supported by a *PulseAudio* server.
  

  { WSLGd

   `WSLGd` is the first process launched after `init`. This process is similar to a daemon and
      • starts *Weston* (with XWayland) and *PulseAudio* and
      • then launces `→ Windows/dirs/Windows/System32/mstsc_exe` on the host in silent mode in order to establish an RDP connection.

    There seems to be no visible process or an executable (binary) with this name.

  }
  { System Distro

    The → https://github.com/microsoft/wslg#wslg-system-distro[WSLg System Distro] is a containerized Linux environment based on → Linux/distributions/CBL-Mariner where the following components are running.
    table { ll
       ☰ ~Env var~
      WSLg XServer ☰ `$DISPLAY`
      Wayland server ☰ `$WAYLAND_DISPLAY`
      PulseAudio server ☰ `$PULSE_SERVER`
    table }

  }
  { Misc

    See also Steve Pronovost's post on the → https://devblogs.microsoft.com/commandline/wslg-architecture/[WSLg architecture].

   `→ Linux/fhs/mnt/wslg`, `→ Linux/fhs/mnt/wslg/distro`,
   `/mnt/c/ProgramData/Microsoft/WSL/.wslgconfig`

  }
}
{ Enabling WSL in a Windows console

  WSL must be specifically enabled before it can be started. It's possible to enable WSL from the command line with elevated privileges. In order for the enabling to take effect,
  the computer needs to be restarted.

  WSL (Version 1?) is enabled `→ Windows/dirs/Windows/System32/cmd_exe` with
code {
C:\> → Windows/dirs/Windows/System32/Dism_exe[dism] /online /enable-Feature /featureName:Microsoft-Windows-Subsystem-Linux
code }

  In → Windows/PowerShell, it can be enabled with
code {
PS:\> → Windows/PowerShell/command-inventory/noun/windowsOptionalFeature/enable[enable-WindowsOptionalFeature] -online -featureName microsoft-Windows-Subsystem-Linux
code }

}
{ Distribution(s)

? After the Subsystem for Linux is installed, a distribution needs to be chosen:
code {
C:\Users\Rene> → Windows/dirs/Windows/System32/bash_exe[bash]
Windows Subsystem for Linux has no installed distributions.
Distributions can be installed by visiting the → Microsoft/Store:
https://aka.ms/wslstore
code }

  { Finding distributions #wsl-l-o

    Distributions that are available from the *online store* can be listed like so:
code {
C:\> → Windows/dirs/Windows/System32/wsl_exe[wsl] --list --online
The following is a list of valid distributions that can be installed.
The default distribution is denoted by '*'.
Install using 'wsl --install -d <Distro>'.

  NAME                                   FRIENDLY NAME
* Ubuntu                                 Ubuntu
  Debian                                 Debian GNU/Linux
  kali-linux                             Kali Linux Rolling
  Ubuntu-18.04                           Ubuntu 18.04 LTS
  Ubuntu-20.04                           Ubuntu 20.04 LTS
  Ubuntu-22.04                           Ubuntu 22.04 LTS
  OracleLinux_8_5                        Oracle Linux 8.5
  OracleLinux_7_9                        Oracle Linux 7.9
  SUSE-Linux-Enterprise-Server-15-SP4    SUSE Linux Enterprise Server 15 SP4
  openSUSE-Leap-15.4                     openSUSE Leap 15.4
  openSUSE-Tumbleweed                    openSUSE Tumbleweed
code }

    A list of downloadable (`.appx`) distributions is → https://learn.microsoft.com/en-us/windows/wsl/install-manual#downloading-distributions[here].

  }
  { Install distro

code {
→ Windows/dirs/Windows/System32/wsl_exe[wsl] --install --distribution Debian
code }

   { WslRegisterDistribution failed with error: 0x800701bc

    *2023-05-18* on a new laptop, when trying to install Debian, I received the error *0x800701bc* along with a link to → https://aka.ms./wsl2kernel where I could find more information.

     This link told me to → #wsl-linux-kernel-update[install the Linux kernel update].

   }
   { WslRegisterDistribution failed with error: 0x80370102

     Still on the *2023-05-18* on a new laptop after updating the kernel, I got the *0x800701bc* error along with a link to → https://aka.ms./enablevirtualization.

     This link suggested to enable hypervisor launch in the boot configuration with `→ Windows/dirs/Windows/System32/bcdedit_exe`:
code {
→ Windows/dirs/Windows/System32/bcdedit_exe[bcdedit] /set hypervisorlaunchtype Auto
code }

     However, even after rebooting the system and verifying that virtualization was enabled in the BIOS, this didn't work.

     The next attempt was to enable *VirtualMachinePlatform* (which then seemed to finally work!)
code {
PS:\> → Windows/PowerShell/command-inventory/noun/windowsOptionalFeature/enable[enable-WindowsOptionalFeature] -online -featureName VirtualMachinePlatform -all
code }
 

   }
   { Old attempts

  (*The following describes an unsuccessful attempt of mine to install a distribution*).

    Download links for the distros can be found → https://docs.microsoft.com/en-us/windows/wsl/install-manual[here] and → https://docs.microsoft.com/en-us/windows/wsl/install-win10[here].

code {
    $ProgressPreference = 'SilentlyContinue'   ## Does this make the download time shorter???
rem invoke-webRequest -Uri https://aka.ms/wsl-ubuntu-1604    -outFile Ubuntu.appx -useBasicParsing
    invoke-webRequest -Uri https://aka.ms/wsl-kali-linux-new -outFile kali.appx   -useBasicParsing

    add-→ Windows/PowerShell/command-inventory/noun/appxPackage[appxPackage] .\kali.appx
code }

  Unfortunately, even after executing `add-appxPackage …`, there is no distribution installed:
code {
C:\Users\Rene> wsl
Windows Subsystem for Linux has no installed distributions.
Distributions can be installed by visiting the Microsoft Store:
https://aka.ms/wslstore
code }

    }
  }
  { Removing a distro

code {
C:\> → Windows/dirs/Windows/System32/wsl_exe[wsl] --unregister <distro name>
code }

  }
  { Location

    The distributions are stored in `→ Windows/dirs/Users/username/AppData/Local/Packages/WSL-distro`

  }


}
{ Update WSL 1 to WSL 2

  In order to be able to use WSL 2, the *Virtual Machine Platform* → Windows/optional-features[optional feature] must be enabled:
code {
C:\users\rene> → Windows/dirs/Windows/System32/wsl_exe[wsl] --set-default-version 2
Please enable the Virtual Machine Platform Windows feature and ensure virtualization is enabled in the → hardware/BIOS
For information please visit → https://aka.ms/wsl2-install
code }

  The *Virtual Machine Platform* can be enabled like so (with elevated privileges):
code {
C:\users\rene> → Windows/dirs/Windows/System32/Dism_exe[dism] /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
code }

  However, I still receive an error:
code {
C:\users\rene> → Windows/dirs/Windows/System32/wsl_exe[wsl] --set-default-version 2
Error: 0x1bc
For information on key differences with WSL 2 please visit → https://aka.ms/wsl2
code }

  → https://github.com/microsoft/WSL/issues/5651[This thread] seems to contain some information on how to get around this issue. It is suggested that the kernel needs to be installed into
  → Windows/dirs/Windows/System32/lxss/tools[`C:\Windows\System32\lxss\tools`].
  -
  I was able to to that by → #wsl-linux-kernel-update[updating the Linux kernel].

  Installing (updating) the kernel seemed to work, setting the default version to 2 works now:
code {
C:\users\rene> → Windows/dirs/Windows/System32/wsl_exe[wsl] --set-default-version 2
For information on key differences with WSL 2 please visit → https://aka.ms/wsl2
code }

}
{ Install Linux kernel update #wsl-linux-kernel-update

code {
    cd $env:temp
    $progressPreference = 'SilentlyContinue'
    → Windows/PowerShell/command-inventory/noun/webRequest/invoke[invoke-webRequest] -uri → https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi -outFile WSLUpdate.msi -useBasicParsing
rem → Windows/PowerShell/command-inventory/noun/webRequest/invoke[invoke-webRequest] -uri → https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi                        -useBasicParsing

rem → Windows/dirs/Windows/System32/msiexec_exe[msiexec] /package WSLUpdate.msi     /quiet
    → Windows/dirs/Windows/System32/msiexec_exe[msiexec] /package WSLUpdate.msi     /passive
rem → Windows/dirs/Windows/System32/msiexec_exe[msiexec] /package wsl_upate_x64.msi /quiet
code }

}
{ Reset password

  In Windows (not Linux!) command line
code {
C:\users\rene> debian config --default-user root
C:\users\rene> debian
root@DESKTOP-1SDJMCL:~# passwd rene
…
root@DESKTOP-1SDJMCL:~# exit
C:\users\rene> debian config --default-user rene
code }

  Replace `debian` with the name of the distro for which the password needs to be reset.

}
{ Starting a distribution

  The parameter `-d` of `wsl` specifies the distribution to be started. (The distribution must have been installed beforehand)
code {
C:> wsl -d Debian
code }

  Alternatively, a distribution can be started like so:
code {
C:\> kali
code }

}
{ Accessing the «other» filesystem

  { DrvFS

    → https://learn.microsoft.com/en-us/archive/blogs/wsl/wsl-file-system-support#drvfs[DrvFs] is a filesystem that allows WSL to mount NTFS and ReFS volumes.

    DrvFS provides the following → Linux/shell/commands/mount#mount-options[mount options]:
    table { ll
      `uid` ☰ User ID of the owner of the mounted files.
      `gid` ☰ Group ID of the group-owner of the mounted files. 
      `umask` ☰ 
      `fmask` ☰
      `dmask` ☰
      `metadata` ☰ If set, Linux file permissions are stored in metadata of mounted files
      `case` ☰ Case sensitivity of directory(?) names
    table }

  }
  { Accessing the Windows Filesystem from WSL

    With DrvFS, a Windows drive is (typically) mounted to `/mnt/<drive>` (the root of the default mount path can be changed with the `root` setting under `[automount]` in `→ Linux/fhs/etc/wsl_conf`):
code {
$ ls → Linux/fhs/mnt[/mnt]/c
$ ls → Linux/fhs/mnt[/mnt]/d
…
code }

    A newly plugged in external harddisk can be mounted within WSL like so. The following example assumes that the mounted files need to be accessible by the user whose id is 1000 and corresponding group id is also 1000:
code {
$ → Linux/shell/commands/sudo mkdir /mnt/e
$ → Linux/shell/commands/sudo → Linux/shell/commands/mount -t drvfs E: /mnt/e -o uid=1000,gid=1000,fmask=133,dmask=022
code }

    TODO: Should the → Linux/shell/commands/mount#mount-options[mount options] (specified with `-o`) be
code {
$ → Linux/shell/commands/sudo → Linux/shell/commands/mount -t drvfs E: /mnt/e -o uid=1000,gid=1000,fmask=177,dmask=077
code }

  }
  { Accessing WSL Filesystem from Windows

    In the explorer, the installed WSL filesystem can be accessed via `\\wsl$\…` or `\\wsl.localhost\…`.

    It's thus possible to map a network drive to a running WSL instance:
code {
C:\> → Windows/dirs/Windows/System32/net_exe/use L: \\wsl$\Debian
The command completed successfully.

C:\> L:
L:\> → Windows/dirs/Windows/System32/cmd_exe/commands/dir
…
2020-09-03  01:56 AM    <DIR>          → Linux/fhs/bin[bin]
2020-07-10  11:04 PM    <DIR>          → Linux/fhs/boot[boot]
2022-06-01  12:41 AM    <DIR>          → Linux/fhs/dev[dev]
2022-06-01  12:30 AM    <DIR>          → Linux/fhs/etc[etc]
…
L:\> → Windows/dirs/Windows/System32/cmd_exe/commands/cd etc
L:\> → Windows/dirs/Windows/System32/notepad_exe[notepad] → Linux/fhs/etc/wsl_conf[wsl.conf]
code }

    This mapping is possible because the WSL client runs a → https://en.wikipedia.org/wiki/9P_%28protocol%29[9P protocol] file server for which the Windows host s a client (See for example the output of
   `→ Linux/shell/commands/dmesg | → Linux/shell/commands/grep 9p`).
    -
    The communication between WSL and Windows runs over AF_UNIX sockets.

  }
}
{ Networking

  Starting from Windows 11 22H2 and WSL 2.0.9 or later, Windows firewall rules will by default apply to WSL (but see
  also → https://learn.microsoft.com/en-us/windows/security/operating-system-security/network-security/windows-firewall/hyper-v-firewall[configuring Hyper-V firewalls]).

  { TCP/IP connections between the WSL guest and the host

    { From the host or network to the guest

      The IP address(es) of the WSL guest can be obtained from within WSL in a shell like so:
code {
$ → Linux/shell/commands/hostname -I
172.31.17.20 172.18.0.1 172.17.0.1 172.19.0.1 172.20.0.1
code }

      These IP addresses  can be accessed from the host, for example by accessing a webserver with `https://172.31.17.20:8080/`.

    }
    { From the guest to the host

code {
$ → Linux/shell/commands/ip route show | → Linux/shell/commands/grep -i default | → development/languages/awk '{ print $3}'
172.31.16.1
code }

    }
  }
}
{ Accessing an USB device #wsl-usb

  WSL → https://learn.microsoft.com/en-us/windows/wsl/connect-usb[cannot natively access a USB device], but (with WSL 2 only?), it's possible with → https://github.com/dorssel/usbipd-win[usbipd-win].

  { Prepare Kernel
  
    In order to be able to mount an USB device, the kernel must be → #wsl-compile-kernel[compiled] with *Mass USB* enabled (by setting config optition `CONFIG_USB_STORAGE` to `y`)
    because → https://youtu.be/I2jOuLU4o8E[the default WSL kernel also does not have support for USB storage device].

code {
$ → Linux/kernel/source/scripts/config --enable USB_STORAGE
code }

  }
  { Install usbip on the WSL guest

    On the WSL guest, `→ Linux/shell/commands/usbip` must be installed (for example when running Debian or Ubuntu):
code {
$ sudo apt install -y usbip usbutils hwdata
code }

  }
  { Install usbipd on the Host 

    On Windows (the host), usbipd (usbip-daemon) must be installed. This tools comes with
      • A → Windows/services called *usbipd* (display name: *USBIP Device Host*).
      • A command line tool, also named → Windows/dirs/Program-Files/usbipd-win#usbipd-exe[`usbipd`]. The location of this tool (`→ Windows/dirs/Program-Files/usbipd-win`) will be added to the `→ Windows/development/environment-variables/PATH` environment variable.
      • A firewall rule, again called *usbipd*, to allow all local subnets to connect to the service. This firewall rule can be modified to fine tune access control.  (If using a third-party firewall, you may have to reconfigure it to allow incoming connections on TCP port 3240.)

    usbipd-win can be installed with the following command line (which requires elevated privileges at one point)
code {
C:\> → Windows/dirs/Users/username/AppData/Local/Microsoft/WindowsApps/winget_exe[winget] install dorssel.usbipd-win
code }

    Winget tells to in reboot Windows, but as far as I can tell this is only to make sure that `PATH` is updated so that it contains `usbipd.exe`.
 
    The result of the following commands indicate that the installation is ok:
code {
PS C:\> (get-service usbipd).status
Running

PS C:\> → Windows/dirs/Windows/System32/netsh_exe/advfirewall/firewall/show rule name=usbipd | select-string Enabled
Enabled:                              Yes

PS C:\> & "C:\Program Files\usbipd-win\usbipd.exe" list
…
code }


    Then, list the USB devices attached to the host:
code {
C:\> usbipd list
BUSID  VID:PID    DEVICE                                                        STATE
1-3    abcd:1234  USB-Massenspeichergerät                                       Not attached
1-8    04f2:b67c  Integrated Camera, Integrated IR Camera                       Not attached
code }

    Binding a USB-ID shares the USB device:
code {
C:\> usbipd bind --busid=1-3
code }

    It can now be attached to WSL;
code {
C:\> usbipd attach --wsl --busid=1-3
usbipd: info: Using WSL distribution 'Debian' to attach; the device will be available in all WSL 2 distributions.
usbipd: info: Using IP address 172.31.16.1 to reach the host.
code }

    Note: `usbipd attach` requires elevated privileges.

    An attached USB device can be detached with `usbipd detach …`.

  }
  { Again in WSL

    Now, in WSL:
code {
$ → Linux/shell/commands/lsusb
Bus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 001 Device 002: ID abcd:1234 LogiLink UDisk flash drive                         <<<< this one was added
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
code }

    The inserted USB device can finally be mounted:
code {
$ sudo mkdir → Linux/fhs/mnt[/mnt]/usb
$ sudo mount → Linux/fhs/dev/sdX[/dev/sdd1] /mnt/usb
$ → Linux/shell/commands/ls /mnt/usb
…
code }

  }
  { TODO

    Uh oh:
code {
$ sudo mount /dev/sdf1  /mnt/f
mount: /mnt/f: unknown filesystem type 'ntfs'.

$ cat → Linux/fhs/proc/filesystems[/proc/filesystems]
code }

  }

}
{ Interoperability #wsl-interoperability

  Interoperability allows to execute Windows and Linux binaries from both, a Windows command terminal or a Linux shell.

 `→ Windows/dirs/Windows/System32/wsl_exe` allows to *run → Linux[Linux] binaries* from the Windows Command Prompt (→ Windows/dirs/Windows/System32/cmd_exe[cmd.exe], → Windows/PowerShell):
code {
C:\> wsl → Linux/shell/commands/ls -l
code }

    Thus, it is possible, for example, to update a WSL distribution when being in Windows:
code {
C:\> wsl → Linux/shell/commands/sudo → Linux/APT/commands/apt-get update
code }

  The output of a Linux command executed via WSL can be piped to a Windows binary:
code {
C:\> wsl → Linux/shell/commands/ls -1 | → Windows/dirs/Windows/System32/findstr_exe[findstr] /i xyz
code }

  On the other hand, it is also possible to execute Windows bineries from WSL:
code {
$ → Linux/fhs/mnt[/mnt]/c/Windows/→ Windows/dirs/Windows/explorer_exe
code }

  Interoperability can be enabled/or disabled:
code {
echo 0 > → Linux/fhs/proc/sys/fs/binfmt_misc/WSLInterop
…
echo 1 > → Linux/fhs/proc/sys/fs/binfmt_misc/WSLInterop
code }

  A Windows executable that is started from WSL runs with the permissions of the user that ran `→ Windows/dirs/Windows/System32/wsl_exe`.

  DriveFS is a → #wsl-file-system[file system] that makes interoperability possible.

}
{ Environment variables

  Some aspects of WSL are controlled by a few → development/environment-variable[environment variables].

  { $WSL_DISTRO_NAME

    A shell started with `wsl` defines the environment variable `$WSL_DISTRO_NAME` whose value corresponds
    to the running Linux distribution.

    For example, when stared in → Windows/dirs/Windows/System32/cmd_exe[`cmd.exe`]:
code {
C:\> wsl -d kali-linux -- echo $WSL_DISTRO_NAME
kali-linux
code }

  Or in → Windows/PowerShell (note the backtick to escape the special meaning of the dollar symbol in PowerShell):
code {
PS C:\> wsl -d Debian -- echo `$WSL_DISTRO_NAME
Debian
code }

  }
  { $WSL_INTEROP #WSL_INTEROP

    See `→ Linux/fhs/run/WSL`

  }
  { $WSLENV

   `WSLENV` controls how (other) environment variables flow between WSL and Win32.

  }
  { PULSE_SERVER

    The value of `PULSE_SERVER` is `→ Linux/fhs/mnt/wslg/PulseServer`.

  }

}
{ Registry

  Some information about the WSL installation is stored in the → Windows/registry under the keys:
    • `→ Windows/registry/tree/HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Lxss` (where a WSL distribution can be renamed)
    • `→ Windows/registry/tree/HKEY_LOCAL_MACHINE/Software/Microsoft/Windows/CurrentVersion/Lxss`
    • `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\P9NP`

}
{ Enabling systemd #wsl-systemd

  → Linux/init/systemd can be enabled by adding `systemd=true` under the `[boot]` section of `→ Linux/fhs/etc/wsl_conf`.

  On a WSL distribution without enabled systemd, I observe the following:
code {
$ → Linux/shell/commands/ps -o cmd= 1
/init

$ → Linux/shell/commands/ls -d → Linux/fhs/run/systemd
ls: cannot access '/run/systemd': No such file or directory
code }

  This is on a distribution where systemd is enabled:
code {
$ → Linux/shell/commands/ps -o cmd= 1
/sbin/init

$ → Linux/shell/commands/file /sbin/init
/sbin/init: symbolic link to /lib/systemd/systemd

$ → Linux/shell/commands/ls -d → Linux/fhs/run/systemd
/run/systemd
code }

}
{ Compile a new Kernel #wsl-compile-kernel

  Install required tools
code {
sudo apt install -y git
sudo apt install -y bc
sudo apt install -y build-essential
sudo apt install -y flex                 # required for example for scripts/kconfig/lexer.lex.c
sudo apt install -y bison                # bison -o scripts/kconfig/parser.tab.c --defines=scripts/kconfig/parser.tab.h -t -l scripts/kconfig/parser.y
sudo apt install -y libssl-dev
sudo apt install -y libelf-dev
sudo apt install -y dwarves              # for pahole and creation of .tmp_vmlinux.btf?
code }

code {
$ → development/version-control-systems/git/commands/clone[git clone] → development/version-control-systems/git/commands/clone#git-shallow-clone[--depth 1] → https://github.com/microsoft/WSL2-Linux-Kernel
$ cd WSL2-Linux-Kernel
$ cp → https://github.com/microsoft/WSL2-Linux-Kernel/blob/master/Microsoft/config-wsl[Microsoft/config-wsl] → Linux/kernel/source/_config
code }

  The copied `.config` file enables (quite possibly among others) the → Linux/kernel/CONFIG[config symbol] `HYPERV`:
code {
$ grep CONFIG_HYPERV= .config
CONFIG_HYPERV=y
code }

  When I tried to build the Kernel (version WSL 5.15) with the copied `.config` file, → https://github.com/microsoft/WSL/issues/10299[I encountered] the error message: *FAILED: load BTF from vmlinux: No such file or directory*.
  -
  I could solve this by commenting the config option `CONFIG_DEBUG_INFO_BTF` in the `.config` file.
  -
 *Update 2023-12-15* (WSL 5.15.133): This step did not seem to be necessary anymore.

  Playing Youtube movies in Chrome resulted in choppy audio on a ThinkPad notebook.
  -
  → https://github.com/microsoft/wslg/issues/684#issuecomment-1069636509[This comment] suggested to set the → Linux/kernel/CONFIG[config symbol] `CONFIG_HZ_1000` to `y` and then recompile the Kernel to solve the issue:
code {
$ → Linux/kernel/source/scripts/config --enable HZ_1000
code }

  Similarly, in order to be able to → #wsl-usb[mount an USB device], the config option `CONFIG_USB_STORAGE` must be set to `y`.

code {
$ → Linux/kernel/compilation/make/oldconfig[make oldconfig]
code }

   Building the Kernel:
code {
$ → development/make -j$(→ Linux/shell/commands/nproc)
code }

  The new Kernel can then be copied to the WSL host:
code {
$ WINUSER=Rene
$ bzImageName=bzImage-chopy-audio
$ cp arch/x86_64/boot/bzImage /mnt/c/Users/$WINUSER/$bzImageName
code }

  It's necessary to tell the host where the new Kernel is located:
code {
$ echo "[wsl2]
kernel=C:\\\\Users\\\\$WINUSER\\\\$bzImageName
" > → Windows/dirs/Users/username/_wslconfig[/mnt/c/Users/$WINUSER/.wslconfig]
code }

  Finally, the new kernel can be started by shutting down and restarting wsl:
code {
C:\> → Windows/dirs/Windows/System32/wsl_exe[wsl] --shutdown
C:\> → Windows/dirs/Windows/System32/wsl_exe[wsl]
code }

  { TODO: Alternative building commands

    As per an answer I got on this → https://github.com/microsoft/WSL/issues/10299[issue], the kernel can alternatively be built with
code {
$ → Linux/shell/commands/sudo → Linux/package-managers/APT/commands/apt install -y build-essential flex bison dwarves libssl-dev libelf-dev bc
$ make KCONFIG_CONFIG=Microsoft/config-wsl
code }

  }

}
{ Win API

  There are some → https://learn.microsoft.com/en-us/windows/win32/api/_wsl/[WSL related functions in the WinAPI]. These are declared in → https://learn.microsoft.com/en-us/windows/win32/api/wslapi/[`<wslapi.h>`].

}
{ Misc

  `→ Linux/fhs/etc/hosts` inherits the entries from → Windows/dirs/Windows/System32/drivers/etc/hosts[`%windir%\system32\drivers\etc\hosts`].

  → Linux/fhs/bin/wslpath[`wslpath`] performs WSL/Windows path conversions:
code {
$ wslpath C:/Users/Rene
/mnt/c/Users/Rene

$ wslpath -w /mnt/c/Users/Rene/
C:\Users\Rene

$ wslpath -m /mnt/c/Users/Rene/
C:/Users/Rene
code }

  { Installation of Chrome in Debian/Ubuntu

   `curl` does not seem to be installed, therefore, downloading the `.deb` file with `wget`:
code {
# curl https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb -o /tmp/chrome.deb
$ wget   https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb -O /tmp/chrome.deb
code }

code {
$ sudo apt -y --fix-broken install /tmp/chrome.deb
code }

    This installs → development/web/browser/Chrome, but sound is missing

  }
  { Better fonts

    A few times after installing Debian, I found fonts to be crappy (especially in the URL bar) - but I have also had some problems with monospace fonts in both Chrome and → development/vim[gvim].

    I was somehow able to mitigate the problems by installing *fonts-noto*:
code {
$ sudo apt install -y fonts-noto
code }

    Installing fontos-noto improved fonts in Chrome's URL bar, but Monospace in  was unreadable and Chrome.
    -
    I could solve the monospace font problem in Chrome by going to `chrome://settings/fonts` and then scrolling down to *Fixed-width font* and replacing *Monospace* with *Liberation Mono*.

  }
  { No sound

    A few times, I had no sound. Installing *pavucontrol* fixed this, too:
code {
$ sudo apt install -y pavucontrol
code }

  }
  { Failed to configure network (networkingMode Nat). To disable networking, set `wsl2.networkingMode=None` in C:\Users\Rene\.wslconfig

    After updating Windows, I couldn't start WSL anymore, the error message being:
code {
Failed to configure network (networkingMode Nat). To disable networking, set `wsl2.networkingMode=None` in → Windows/dirs/Users/username/_wslconfig[C:\Users\Rene\.wslconfig]
Error code: Wsl/Service/CreateInstance/CreateVm/ConfigureNetworking/HNS/0x80070424

[process exited with code 4294967295 (0xffffffff)]
You can now close this terminal with Ctrl+D, or press Enter to restart.
Failed to configure network (networkingMode Nat). To disable networking, set `wsl2.networkingMode=None` in C:\Users\Rene\.wslconfig
Error code: Wsl/Service/CreateInstance/CreateVm/ConfigureNetworking/HNS/0x80070424

[process exited with code 4294967295 (0xffffffff)]
You can now close this terminal with Ctrl+D, or press Enter to restart.
code }

    I was able to start WSL again by going to → Windows/configuration/Start-menu[Start menu], searching for *Turn Windows features on or off* and then enabling *Virtual Machine Platform* (also referred to as VPM).

    See also → https://github.com/microsoft/WSL/issues/10709[WSL Networking Broken in 2.0.7].

  }
  { Kernel modifications

    This is an *incomplete* list of differences between the kernel source tree and the WSL copy.

    One of the kernel modifications in the sources is the addition of the `→ Linux/kernel/source/drivers/hv/dxgkrnl` directory.

    WSL does not have `→ Linux/kernel/source/tools/testing/selftests/nolibc` (but `→ Linux/kernel/source/tools/include/nolibc` is present, however with a reduced set of files).

  }
}
{ TODO

  { wsl --install --no-distro

    → https://twitter.com/craigaloewen/status/1717169552943976636[This tweet] suggests:
code {
wsl --install --no-distro
code }

Restart the machine.

code {
wsl --import <yourDistro>
code }

    A small distribution to import is → https://alpinelinux.org/downloads/[Alpine Linux].

  }
  { No sound

    { Attempt one

      *ALSA lib confmisc.c:767:(parse_card) cannot find card '0'*
code {
sudo apt install libpulse0
code }

   Possibly also?
code {
sudo apt install libjack-jackd2-0
code }

    }
    { Attempt two

      In a WSL 2 Debian installation, I had sound in Chrome, but when trying use a → Kunst/Musik/Csound frontend (`blue`, `csoundqt`), these were mute. `csoundqt` issued this error message
     *PortAudio V19.6.0-devel, …   error: No sound device is available … closing device* and *Failed to initialize real time audio output*.

      After installing the following package and restarting the WSL distro, I had sound for both, Chrome and csound frontends:
code {
sudo apt-get install libasound-dev
code }

    }

  }
  { GPU #wsl-gpu

    The `KConfig` file in `→ Linux/kernel/source/drivers/hv` has an interesting → https://github.com/microsoft/WSL2-Linux-Kernel/blob/f53bd0a62a32304fb24820768bb80de25589e838/drivers/hv/dxgkrnl/Kconfig#L18C21-L28C75[note]:
    -
    When WSL is instantiated, the Windows host assigns compatible host GPU adapters to the container.
    -
    The corresponding virtual GPU devices appear on the PCI bus in the container. These devices are enumerated and accessed by this driver.
    -
	  Communications with the driver are done by using the Microsoft *libdxcore* library, which translates the  → https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/d3dkmthk[D3DKMT interface] to the driver IOCTLs (apparently exposed via `→ Linux/fhs/dev/dxg`).
    The virtual GPU devices are paravirtualized, which means that access to the hardware is done in the host. The driver communicates with the host using → https://docs.kernel.org/virt/hyperv/vmbus.html[Hyper-V VM bus] communication channels.

    MS Devblogs:
      • → https://devblogs.microsoft.com/directx/directx-heart-linux/[DirectX is coming to the Windows Subsystem for Linux]
      • → https://devblogs.microsoft.com/commandline/wslg-architecture/#hardware-accelerated-opengl[Hardware accelerated OpenGL]

    → https://developer.nvidia.com/cuda/wsl[CUDA on Windows Subsystem for Linux] where a link leads to → https://www.nvidia.com/Download/index.aspx?lang=en-us[NVIDIA driver downloads].
    -
    Intel drivers can be downloaded from → https://www.intel.com/content/www/us/en/homepage.html?ref=https://www.intel.com/content/www/us/en/download/19619.html[here] (→ https://www.intel.com/content/www/us/en/download-center/home.html[Download center])
    -
    AMD drivers can be downloaded from → https://community.amd.com/t5/radeon-pro-graphics/announcing-amd-support-for-gpu-accelerated-machine-learning/ba-p/414185[here].
 
    Does the existence of `→ Linux/fhs/usr/lib/wsl/lib/libcuda_so_1` indicate that the GPU driver was installed on the host?
    -
    And what about `→ Linux/fhs/usr/lib/wsl/lib[/usr/lib/wsl/lib]/nvidia-smi`?

    { GPU selection in WSLg

      → https://github.com/microsoft/wslg/wiki/GPU-selection-in-WSLg[This article] describes how or which GPU is selected by MESA when running agaings WSLg's d3d12 backend.
      -
      Two key take aways of this article for me were:
        • Newer versions of MESA with the d3d12 backend choose the first enumerated integrated GPU.
        • The environment variable `MESA_D3D12_DEFAULT_ADAPTER_NAME` can be set to a substring of the name of the GPU that should be selected
        • `glxinfo -B` shows which GPU is currently used

    }
    { Diagnosis of problems

code {
$ glxinfo -B
$ glxinfo -B | grep -P 'OpenGL renderer string|Device:'
$ nvidia-smi
$ nvidia-smi -L
$ dmesg | grep dxg
code }

    }

  }
  { Developer mode

    It seems that → Windows/development/developer-mode[developer mode] was needed (but is not anymore) to enable the WSL.

  }
  { Change display language of WSL

code {
$ sudo update-locale LANG=en_US.UTF8
code }

  }
  { Pico Processes #wsl-pico-processes

    → https://docs.microsoft.com/en-us/archive/blogs/wsl/pico-process-overview[Pico Processes] are the foundation of WSL. (See also → Windows#win-DrawBridge[DrawBridge])

  }
  { System Calls (syscalls) #wsl-syscall

    All → Linux/kernel/sys-calls[(Linux) System Calls] are → https://needleinathreadstack.wordpress.com/2017/01/20/windows-subystem-for-linux-file-reads/[fullfilled by a pico provider].

    { lxcore.sys / lxss.sys

    ? This provider is implemented by `→ Windows/dirs/Windows/System32/drivers/lxss_sys` and `→ Windows/dirs/Windows/System32/drivers/lxcore_sys`: they coordinate such syscall requests with the Windows NT Kernel.

      When the NT Kernel is called with a syscall, the kernel checks if the call came from a *pico process* by checking the state in the process structure (I assume that to be a special flag).
      -
      If this is the case, the kernel saves the register state and «forwards» the call to the *pico driver*. The pico driver then finds the Linux syscall number in the `RAX` register and acts accordingly.
      -
      After having serviced the request, the calling flow is returned to the NT kernel which restores the register state and puts the return value into the `RAX` register.
      -
      Finally, the execution is returned to the WSL process.
    
      A syscall is forwarded to `lxcore.sys` (or `lxss.sys`?) which either (preferrably) dispatches it to an NT syscall or handles it itself.
      -
      An example of a nice mapping between a Linux and NT syscall is `sched_yield()` and `ZwYieldExecution()`.
      -
      On the other hand, `fork()` has no direct equivlent on NT. Therfore, when `lxcore.sys` (or `lxss.sys`?) handles a `fork()` call,
      it prepares the copying of the process, then calls the NT syscall to create a process and finally finishes the copying.

      See also the WSL Blog: → https://docs.microsoft.com/en-us/archive/blogs/wsl/wsl-system-calls[WSL System Calls].

    }

  }
  { File Systems #wsl-file-system

    WSL comes with two file systems:
    table { ll
      VolFS ☰ Cannot be used for → #wsl-interoperability[interoperability]. Provides most features of → Linux/filesystem/virtual[Linux VFS]: permissions, sym-links, FIFOs, sockets and device files. VolFS is used to mount the root file system to `/`.
      DriveFS ☰ Used for → #wsl-interoperability[interoperability]. File names are required to be valid Windows file names and are case insensitive. Windows drives (`C:\` etc.) are mounted to `→ Linux/fhs/mnt[/mnt]/c` etc.).
    table }

  }
  { \Device\lxss

    WSL creates the *device object* (→ Windows/kernel/objects[kernel object]?) `\Device\lxss`, verify with `→ Windows/tools/Sysinternals/Winobj`

  }
  { CreateLxProcess

   `CreateLxProcess()` is → https://docs.microsoft.com/en-us/archive/blogs/wsl/windows-and-ubuntu-interoperability[apparently] a COM method to talk to the *LXSS Manager service*.

    This method is used by `→ Windows/dirs/Windows/System32/bash_exe`.

  }
  { LxBus

   *LxBus* provides a channel, based on sockets, on which NT and WSL processes can communicate by exchanging messages and sharing state.

    This channel is primarily used by the *LXSS Manager service* (NT) and `/init` (WSL).

    LxBus is accessed (from the WSL) side by opending the `→ Linux/fhs/dev[/dev]/lxss` device (which is not shown with `ls /dev/lxss`). `/dev/lxssclient` supports a subset of `/dev/lxss`.

  }
  { /init #wsl-init

   `/init` is mapped from `→ Windows/dirs/Windows/System32/lxss/tools/init` which can be demonstrated like so:
code {
$ diff  /init  /mnt/c/Windows/System32/lxss/tools/init
code }

   *Update* 2024-01-09: On the current environment, this `diff` command now reports a difference.

    This → https://www.reddit.com/r/bashonubuntuonwindows/comments/wa4vju/why_are_there_3_init_processes/[reddit thread] has the following interesting comment:
    "
      The '/init' executable in WSL2 distros is inserted at runtime by WSL2. It is not shipped by each distro. This executable has multiple functions and will appear several times in the process list while you are running the distro.
      -
      … there are at least these responsibilities:
        • run as pid1 to bootstrap the distro when starting it up including setting up wsl specific features,
        • Marshall interop calls between wsl and windows,
        • act as a plan 9 file server to share your windows file system with windows,
        • act as an entry point for binfmt_misc to execute windows binaries via interop.
    "

  }

}

sa:

  → Windows/Subsystem-for-Linux/install-distribution
 
  → Windows/dirs/Windows/System32/lxss[`%SYSTEMROOT%\System32\lxss`]

  → Windows/dirs/Windows/System32/wslapi_dll[`wslapi.dll`]

 `→ Windows/dirs/Users/username/_wslconfig`, `→ Linux/fhs/etc/wsl_conf`

 `→ Linux/fhs/run/WSL`, `→ Linux/fhs/usr/lib/wsl`

 `→ Linux/fhs/etc/ld_so_conf_d/ld_wsl_conf`

  → Linux/shell/commands/ps/WSL[Running `ps` in WSL]

 `→ Windows/dirs/Users/username/AppData/Local/Microsoft/WindowsApps/MicrosoftCorporationII_WindowsSubsystemForLinux_8wekyb3d8bbwe`

  `→ development/tools/scripts/personal/wsl-screenshot-to-clipboard` is use to copy a screenshot made with `→ Windows/dirs/Windows/System32/SnippingTool_exe` into the → Linux/X/clipboard[clipboard] using `→ Linux/X/clipboard/xclip`.

  The presence of `→ Linux/fhs/proc/sys/fs/binfmt_misc/WSLInterop` is a pretty good indicator that a Kernel is running in WSL.

links:

  → https://dev.to/smashse/wsl-chocolatey-powershell-winget-1d6p[Anderson Gama's blog] was quite helpful to demonstrate how the kernel can be installed from the command line.

  → https://wiki.ubuntu.com/WSL has some hints on using WSL 2 and also has links to → Linux/X Servers that can be used with WSL.

  One of the most helpful resources for me to learn some details about WSL were the → https://docs.microsoft.com/en-us/windows/wsl/release-notes[release notes].

  → https://github.com/eliranwong/wsl2[Eliran Wong's notes] (a Github repository).

 `→ Windows/dirs/Program-Files/Hyper-V/VMCreate_exe` allows to quickly install a *Windows 11 dev environment* which comes with WSL 2 and an → Linux/distributions/Ubuntu installation.
