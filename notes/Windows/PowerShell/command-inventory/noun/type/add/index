$ PowerShell cmdLet Add-Type
@ add-type

The `add-type` → Windows/PowerShell/language/cmdlet[cmdLet] allows to load → Microsoft/dot-net framework classes.

Assemblies that were loaded into a → Windows/PowerShell cannot be unloaded anymore and consequenctly, there is no `remove-type` → Windows/PowerShell/language/cmdlet[cmdLet]. There is no other way to get rid of such assemblies from memory but to
restart PowerShell.

{ Adding a DLL to a PowerShell session

  The following simple example tries to demonstrate how a → Windows/development/Portable-Executable/DLL can be added to → Windows/PowerShell session.

  First, we need to create a → Windows/development/Portable-Executable/DLL. We create it from the following source code
  gh|about-PowerShell|/cmdlets/type/add/tq84_type.cs||

  This source is compiled into a DLL with `csc.exe`, the → development/languages/C-Sharp compiler:
code {
PS C:\path\to\somewhere> csc -nologo -target:library .\tq84_type.cs
code }

   The DLL can now be added to the current PowerShell session with the `add-type` → Windows/PowerShell/language/cmdlet[cmdLet]:
code {
PS C:\path\to\somewhere> add-type -path 'tq84_type.dll'
code }

   We verify if the DLL was actually loaded. The following statement reports it as being loaded:
code {
PS C:\path\to\somewhere> [AppDomain]::CurrentDomain.GetAssemblies()
code }

   Now that the DLL is loaded, we can use its functionality. Static methods can be invoked without
   creating an object:
code {
PS C:\path\to\somewhere> [TQ84.T]::twice(21)
42
code }

   In order to invoke member methods, an instance of the class needs to be created. This can be done with
   → Windows/PowerShell/command-inventory/noun/object/new#ps-new-object-dll[`new-object '….dll'`]


}
{ Loading a DLL with Reflection.Assembly

 The .NET class → Microsoft/dot-net/namespaces-classes/System/Reflection/Assembly[`System.Reflection.Assembly`] has the method `LoadFile` that is able to load DLLs as well. It is unclear to me if and what differences there are between using `LoadFile` and `add-type`. (Maybe
 → https://www.leeholmes.com/blog/2006/10/27/load-a-custom-dll-from-powershell[Lee Holmes' blog might help]):
code {
PS C:\path\to\somewhere> [Reflection.Assembly]::LoadFile( (get-item .).fullName + '\tq84_type.dll')
PS C:\path\to\somewhere> [TQ84.T]::twice(21)
code }

}
{ Option -typedef to add a class from C-Sharp #inline-source-code

  With the `-typedef` parameter, `add-type` can be given → development/languages/C-Sharp[C#] source code(!) to compile. `add-type` will then add the result to the current session: 
  gh|about-PowerShell|/cmdlets/type/add/inline.ps1||

}
{ Adding a WinAPI function #add-type-winapi

  The following snippet creates a type with a → Windows/development/WinAPI function so that it can be called from PowerShell.
  gh|about-PowerShell|/cmdlets/type/add/WinApi.ps1||

  When executed, a simple yes-no Message Box is shown:
  gh|about-PowerShell|/cmdlets/type/add/img/WinApi.png||

  See also → Windows/PowerShell/examples/message-box

}
{ -assemblyName

  → https://www.madwithpowershell.com/2013/10/add-type-vs-reflectionassembly-in.html[Most of the time] the following two lines are equivalent:
code {
add-type -assemblyName Windows.Forms
[→ Microsoft/dot-net/namespaces-classes/System/Reflection/Assembly[System.Reflection.Assembly]]::→ Microsoft/dot-net/namespaces-classes/System/Reflection/Assembly/LoadWithPartialName[LoadWithPartialName("Windows.Forms")
code }

}
{ Option -codeDomProvider #add-type-codeDomProvider


  TODO. This option is related to the → Microsoft/dot-net/namespaces-classes/System/CodeDom/Compiler/CodeDomProvider[`System.CodeDom.Compiler.CodeDomProvider`] class.

  Apparently, the `-codeDomProvider` option was removed with → Windows/PowerShell version 6.

}


sa:

  The → Windows/PowerShell/language/statement/using/assembly[`using assembly`] statement.

  → Windows/PowerShell/command-inventory/noun/type

  → Windows/PowerShell/command-inventory/noun/type/add/create-assembly[Creating assemblies with `add-type` and then using them] 
 
  The → Microsoft/dot-net/namespaces-classes/Microsoft/PowerShell/Commands/AddType/AutoGeneratedTypes[`Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes`] namespace.
