$ PowerShell cmdLet add-type

The `add-type` → Windows/PowerShell/language/cmdlet[cmdLet] allows to load → Microsoft/dot-net framework classes.

Assemblies that were loaded into a → Windows/PowerShell cannot be unloaded anymore and consequenctly, there is no `remove-type` → Windows/PowerShell/language/cmdlet[cmdLet]. There is no other way to get rid of such assemblies from memory but to
restart PowerShell.

{ Adding a DLL to a PowerShell session

  The following simple example tries to demonstrate how a DLL can be added to → Windows/PowerShell session.

  First, we need to create a → Windows/development/Portable-Executable/DLL. We create it from the following source code
  gh|about-PowerShell|/cmdlets/type/add/tq84_type.cs||

  This source is compiled into a DLL with `csc.exe`, the → development/languages/C-Sharp compiler:
code {
PS C:\path\to\somewhere> csc -nologo -target:library .\tq84_type.cs
code }

   The DLL can now be added to the current PowerShell session with the `add-type` → Windows/PowerShell/language/cmdlet[cmdLet]:
code {
PS C:\path\to\somewhere> add-type -path 'tq84_type.dll'
code }

   We verify if the DLL was actually loaded. The following statement reports it as being loaded:
code {
PS C:\path\to\somewhere> [AppDomain]::CurrentDomain.GetAssemblies()
code }

   Now that the DLL is loaded, we can use its functionality. Static methods can be invoked without
   creating an object:
code {
PS C:\path\to\somewhere> [TQ84.T]::twice(21)
42
code }

   In order to invoke member methods, an instance of the class needs to be created. This can be done with
   → Windows/PowerShell/command-inventory/noun/object/new#ps-new-object-dll[`new-object '….dll'`]


}
{ Loading a DLL with Reflection.Assembly

 The .NET class → Microsoft/dot-net/namespaces-classes/System/Reflection/Assembly[`System.Reflection.Assembly`] has the method `LoadFile` that is able to load DLLs as well. It is unclear to me if and what differences there are between using `LoadFile` and `add-type`. (Maybe
 → https://www.leeholmes.com/blog/2006/10/27/load-a-custom-dll-from-powershell[Lee Holmes' blog might help]):
code {
PS C:\path\to\somewhere> [Reflection.Assembly]::LoadFile( (get-item .).fullName + '\tq84_type.dll')
PS C:\path\to\somewhere> [TQ84.T]::twice(21)
code }

}
{ Adding a class from inline-source-code

 With the `-typedef` parameter, `add-type` can be given the source code to compile. `add-type` will then add the result to the current session: 
  gh|about-PowerShell|/cmdlets/type/add/inline.ps1||

}
{ -assemblyName

  → https://www.madwithpowershell.com/2013/10/add-type-vs-reflectionassembly-in.html[Most of the time] the following two lines are equivalent:
code {
add-type -assemblyName Windows.Forms
[→ Microsoft/dot-net/namespaces-classes/System/Reflection/Assembly[System.Reflection.Assembly]]::LoadWithPartialName("Windows.Forms")
code }

}


sa:
  → Windows/PowerShell/command-inventory/noun/type
 
  The → Microsoft/dot-net/namespaces-classes/Microsoft/PowerShell/Commands/AddType/AutoGeneratedTypes[`Microsoft.PowerShell.Commands.AddType.AutoGeneratedTypes`] namespace.

