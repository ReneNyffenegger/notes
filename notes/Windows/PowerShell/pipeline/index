$ Powershell: pipelines
@ pipeline

Contrary to other → Linux/shell[shells], PowerShell pipes → Windows/PowerShell/language/object[objects] rather than text from one → Windows/PowerShell/command-inventory/noun/command[command] to another.

{ Pipeline parameter binding

  A (non-beginning) command within a pipeline needs to know which *parameter* will get the object from the previous command.
  -
  This is determined in a process called *pipeline parameter binding*.

  There are two means:
    • *ByValue*
    • *ByPropertyName*
    
}
{ Last cmdlet

  PowerShell automatically pipes the last command of a pipeline into the → Windows/PowerShell/command-inventory/noun/default/out[`out-default` cmdlet].

  By default, `out-default` invokes `out-host` for a stream of strings.

}
{ Removing objects from the pipeline

  → Windows/PowerShell/command-inventory/noun/object/where[`where-object` cmdLet] allows to specify a condition that determines which objects are kept in the pipeline.

  Object that don't satisfy the specified conditions are discarded from the pipeline, that is, they are not passed to the next
  → Windows/PowerShell/language/cmdlet[cmdLet] in the pipeline.

}

{ One at a time vs All objects at once

  { All object at once

    `get-process` returns an → Windows/PowerShell/language/type/array[array] of objects. Thus, the following statement prints the members of an array:
code {
PS C:\> get-member -inputObject (get-process)

   TypeName: System.Diagnostics.Process
   …
code }

  }
  { One object at a time

    However, when the result of `get-process` is piped into another command, the command receives one object at a time. Thus, `get-member` in the following pipeline
    prints the members of a *System.Diagnostic.Process*, which is the type of the objects returned by `get-process`.

    Because `get-member` eliminates duplicates, we only see each member only once.

code {
PS C:\> get-member -inputObject (get-process)

   TypeName: System.Object[]
   …
code }

  }
}

{ Multiple pipelines

  Technically, → Windows/PowerShell has mutliple pipelines:
    • (normal) output (mimicking → development/stdin-stdout-stderr[STDOUT])
    • errors (mimicking *STDERR*)
    • verbose command messages
    • debugging information

}
{ Experimental features

  PowerShell Core uses → Windows/PowerShell/command-inventory/noun/experimentalFeature[experimental features] to play with the possibility to chain pipeline invocations with `&&` and `||`.

  This featues can be enabled with
code {
PS C:\> enable-→ Windows/PowerShell/command-inventory/noun/experimentalFeature[experimentalFeature] PSPipelineChainOperators
code }

}

sa:
  The `$_` → Windows/PowerShell/language/variable/automatic[automatic variable].

  → Windows/PowerShell/pipeline/formatting[Formatting the output] of a pipeline

  Within a pipeline, a → Windows/PowerShell/language/scriptblock can be executed for each element in the pipeline with the → Windows/PowerShell/command-inventory/noun/object/forEach[`forEach-object` cmdLet].

  If a function participates in a pipeline, the function can use the → Windows/PowerShell/language/variable/automatic[`$input` automatic variable] to refer to the
  → Windows/PowerShell/language/object that is being proessed in a → Windows/PowerShell/language/function/begin-process-end-block[`process` block].
