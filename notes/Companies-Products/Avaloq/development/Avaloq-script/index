
Avaloq script is modeled after → development/databases/Oracle/PL-SQL but does not allow direct (→ development/databases/SQL[SQL]) access.

Used for
  • → Companies-Products/Avaloq/development/report-writer[Report writer]
  • → Companies-Products/Avaloq/order/[Order] validation
  • → Companies-Products/Avaloq/AMI[Avaloq Message Interface]
  • Rule loader
  • → Companies-Products/Avaloq/development/context-action/[Context actions]

{ Vocabulary extensions

  Vocabulary extensions are additional keywords or syntax elements that are added to the basic script vocabulary depending on a
  script's *script type*.

  An example is `area` which is available for the *Report Writer Print Layout* script type.

}
{ Data types

  • `number`
  • `text`
  • `boolean`
  • `long`
  • `date`
  • `raw`
  • `id` (in conjunction with → Companies-Products/Avaloq/development/tables/code[code tables]?)
  • `obj_XYZ`

}
{ Script context

  The script context is a predefined that refers to something depending on the context in which a script is run.

  For example, `doc` refers to the → Companies-Products/Avaloq/order[order] that is verified in an
  order validation.

}
{ lists

  There is the concepts of lists in Avaloq scripts (for example a list of BPs etc.).

  Such lists are not a real data type. Thus, they cannot be saved or stored in a variable. Lists are returned by → Companies-Products/Avaloq/development/DDIC[DDICs] and must be used within a `for … loop`.

  Apparently, there are two associated database → Companies-Products/Avaloq/development/tables[tables] with lists: `list_number` and `list_char`.

The following tow constructs are equivalent, but the second one is preferred.
code {
for i in 1 .. doc.trans_list.count loop
  with doc_trans(doc.trans_list(i)) as t do
    …
  end with;
end loop;

for t_id in doc.trans_list loop
  with doc_trans(t_id) as t do
    …
  end with;
end loop;
code }

  TODO: the → development/databases/Oracle/PL-SQL[PL/SQL] package `db_list#` and the → Companies-Products/Avaloq/development/DDIC[DDIC] `mem_db_list_nr` and `mem_db_list_char`.

}
{ Some Avaloq script constructs

  { with … as … end with;

code {
with mem_doc_XYZ(some_id) as m do
  m.field := …
end with;
code }

  }
  { with new … as do … end with;

code {
with new xfer.… as x do
  x.field := …
end with;
code }

  }
  { require statement

  The `require` statement is used to verify if the input values for a procedure's parameter meet a certain minimal requirement.
code {
procedure foo_bar(
  i_bla      number,
  i_more_bla text
)
is
begin
  require(i_bla > 42, 'i_bla should be greater than 42');
  …

code }

  }
  { assert statement

    Similiarly to the `require` statement, the `assert` statement can be used to test conditions during runtime:
code {
assert(l_foo != 0, 'l_foo = 0');
code }

  }
  { extendable and extension

Packages marked with `extendable` can be overridden by customers. The overriding then needs
the `extension` keyword.

  }
  { abstract, final, protected, private

    These keywords can be used for procedures and functions (Avaloq refers to these as element levels).



  }
  { Booleans in DDICs

Apparently, DDICs don't accept booleans. Instead, `'+'` and `'-'` are used.

  }

}
{ Coding convention

  It's incredible, but Avaloq bothered to create a document (1074) which mandates coding conventions with rather stupid rules.

}
{ Misc

  There is a typed `iff`: `iffb` to compare integers and `iffd` for dates.

}
{ TODO

code {
session.debug(someText);
code }

  Procedures, functions and constants of (predefined) Avaloq packages apparently can be overridden.

  The script package `cntprty_lib` synchronizes a BP's swift key with the linked counter party.

  Apparently, ids of code tables(?) such as `code_postit_sub_type` can be assigned directly in Avaloq script:
code {
c_pit_st_doc_reject constant number := code_postit_sub_type.stex.doc_recject;
code }

}
sa:
  → Companies-Products/Avaloq/development/Avaloq-script/packages

  → Companies-Products/Avaloq/development/sources[sources]

