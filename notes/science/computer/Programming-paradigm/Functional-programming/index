
*Functional programming* is a → science/computer/Programming-paradigm[programming paradigm]. It is largely about applying functions to lists (of values).

The origin of functional programming is the *lambda calculus*.

Functional programming languages require to have → science/computer/Programming-paradigm/Functional-programming/First-class-function[first class functions].

*Pure functions* (or expressions) have no side effects.

{ TODO

  { Lambda Calculus

    Lambda Calculus only has
      • function definitions and
      • function calls

    It notably doesn't have if statements, types, variables, loops and recursion.
    -
    Even though, it can compute anything that a classic language like C can.

   

    Syntax:
    table { ll
      `x` ☰ Variable (which is any letter of the alphabet)
      `λx.e` ☰ Abstraction (i. e. a nameless function where `x` is the argument and `e` is the function's body). The `λ` and the `.` always come together in pairs.
      `e₁ e₂` ☰ Application. `e₁`  evaluates to a function to which `e₂` is applied.
    table }

    Definition of expressions
      • A variable (for example `x`) is a valid λ-term
      • If `t` is a valid λ-term and `x` is a variable, then `λx.t` is a valid λ-term
      • If `t` and `s` are both valid λ-terms, then `t s` is a valid λ-term

   `e₁ e₂ e₃` is the same as `(e₁ e₂) e₃`.

   `λx.x` is an abstraction that represents the *identity function*.

   `λy.λx.x` is a an abstration that ignores its argument (`y`) and returns the identity function (`λx.x`)

   `(λx.x) y` applies the `y` to the function `λx.x`.

    { Currying

      An abstraction (function) can only have one argument (i. e. one letter between the `λ` and the `.`).
      -
      In order to create a function that takes two arguments, two functions must be defined:
        • A function that takes the first argument which creates
	• the function that takes the second argument.

code {
λx. λy. ‥ x ‥ y ‥
code }

      In pseudo code, this is sometimes abbreviated with `λxy. ‥ `

    }
    { Loop

      A loop can be expressed in lambda calculus like so (a function that is applied to itself):
code {
(λx.x x) (λx.x x)
code }

       Because when the function on the right side is applied to the function on the left side, the result is again
code {
(λx.x x) (λx.x x)
code }

?     Allegedly, this formallows to define a loop in a language that doesn't have loops.

    }
    { Y-Combinator

      Is this the Y-Combinator?
code {
λf.(λx.f(x x)) (λx.f(x x))
code }

?     Allegedly, the Y-Combinator allows to define a recursion in a language that doesn't have recursions.

    }

  }

}

sa:

  → science/computer/Programming-paradigm/Functional-programming/First-class-function/map[map],
  → science/computer/Programming-paradigm/Functional-programming/First-class-function/reduce[reduce],
  → science/computer/Programming-paradigm/Functional-programming/First-class-function/fold[fold] and
  → science/computer/Programming-paradigm/Functional-programming/First-class-function/filter[filter].

  → science/computer

  → development/Big-Data#big-data-lambda-architecture[Big Data: Lambda Architecture]

  → development/XML/XQuery is a functional language.
