$ Power Query M formula language

The *Power Query M formula language* is a → science/computer/Programming-paradigm/Functional-programming/[functional language] allows to express the process of → Microsoft/Power-Query#power-query-mashing-up-data[mashing-up data].

Usually, the *Power Query M formula language* is referred to simply *M*.

The language resembles F#.

Surprisingly, the language is als case sensitive.

{ let expression

code {
let
    variableName    = expression,
    anotherVariable = anotherExpression
in
    yetAnotherVariable (?)
code }

}
{ Variable names

  It's possible to defined variable names that contain spaces. They are used with the special `#"…"` syntax:
code {
let
   #"foo bar baz"  = …
    … 
code }

}
{ Literals

  Some literals include
    • `null`
    • `true`, `false`
    • `42`, `0xabcd`
    • `"foo, bar and baz"`, `"The quote reads ""hello world""."`, `"First line#(cr,lf)second line"`
    • `#date(1970,08,28)`, `#datetime(2020,04,18, 12,13,14)`, `#datetimezone(2020,04,18, 12,13,14, 01,00)`, `#duration(1,4,15,0)`, `#time(23,59,59)`

}
{ Keywords

  The keywords include
   `and`, `as`, `each`, `else`, `error`, `false`, `if`, `in`, `is`, `let`, `meta`, `not`, `null`, `or`, `otherwise`, `section`, `shared`, `then`, `true`, `try`,
   `type`, `#binary`, `#date`, `#datetime`, `#datetimezone`, `#duration`, `#infinity`, `#nan`, `#sections`, `#shared`, `#table` and `#time`.

}
{ Comments

  M has → development/languages/C-C-plus-plus[C / C++] like comments:
code {
/*
   This is
   a multi line comment.
*/

// This comment extends to the end of the line.
code }
}
{ Escape character

  `#` is the escape character. Some examples are:
  table { ll
    `#(cr)` / `#(lf)` / `#(cr,lf)` ☰ carriage return / line feed / carriage return line ffedc
    `#(tab)` ☰ tabulator
    `#(263a)` ☰ arbitrary → development/Unicode character (for example: 0x263a = ☺)

  table }

  In order to get the escape character itself, it needs to escaped like so: `#(#)`.

}
{ Two types of values

  M deals with two types of values:
    • primitive values, which seem to be expressable with literals such as `42`, `true`, `"hello world"` etc.
    • constructed values, which consist of other primitive and/or constructed values.

  Primitive types also include the *abstract types*: `function`, `table`, `any` and `none`.

? Strings must be enclosed in double quotes, single quotes do not denote a string.

}
{ Structured data values (Lists, records and tables)

  { Lists

    A list is denoted by curly braces. The following snippet is a list of the first fibonacci numbers:
code {
 { 1, 1, 2, 3, 5, 8, 13 }
code }


  }
  { Records

  `[ fld_1 = 42, fld_2 = "hello world" ]` is a record, whose two fields are `fld_1` and `fld_2`.
 
   A table organizes values in columns and rows.

  }
  { Tables

code {
#table(
  {"col_1","col_2"}, {
  {    42 ,    11 },
  {    17 ,    32 }
})
code }

  }

}
{ Looking up values in lists or tables

  
   { Positional index operator

    Individual items in a list can be looked up by the *positional index operator* (`{n}`), which accesses the (zero-based) item `n`
code {
[
   fibonacci = {1, 1, 2, 3, 5, 8, 13, 21, 34},
   five      =  fibonacci{4} // fifth item is 5
]
code }

  }
  { Accessing values in list of records


code {
[  
  results =   
  {   
      [   
          year       = 2019,   
          val_one    =   42,
          val_two    =   99
      ],  
      [   
          year       = 2020
          val_one    =   47
          val_two    =  103
      ]   
  },  
  sum_val_one = results{0}[val_one] + 
                results{1}[val_one] // equals 42 + 47
]  
code }

  }

}
{ Functions

  A function takes a set of (input) values and prodcues a single result value.

 `(a, b) => a * b` is a function that multiplies two values.

  { each

    The `each` keyword is used to create simple functions that take the underscore (`_`) parameter.

    `each [XYZ]` is equal to `_[XYZ]` which is equal to `(_) => _[XYZ]`

  }


}
{ Evaluation model

  M's evaluation model resembles that of → Microsoft/Office/Excel where values in cells are calculated in order of their dependencies to other cells.

}
{ Interesting function

code {
File.Contents(path as text, optional options as nullable record) as binary
code }

  `File.Contents` return a file's content as `binary`. This is needed, for example, to open an → Microsoft/Office/Excel/Object-Model/Workbook[Excel Workbook] and transform it to a `table` with `Excel.Workbook`:
code {
  Excel.Workbook(workbook as binary, optional useHeaders as nullable logical, optional delayTypes as nullable logical) as table
code }

   `Table.PromoteHeaders` is used if a table's first row contains column names:
code {
Table.PromoteHeaders(table as table, optional options as nullable record) as table
code }


   `Excel.CurrentWorkbook()` returns the current Excel workbook.
code {
Excel.CurrentWorkbook() as table
code }
  `Excel.CurrentWorkbook()` can be used to refer to → Microsoft/Office/Excel/Object-Model/Range#excel-range-name[named ranges] to get values for processing:
code {
var = Excel.CurrentWorkbook(){[Name="rangeName"]}[Content]{0}[Column1],
code }

code {
Table.TransformColumnTypes(table as table, typeTransformations as list, optional culture as nullable text) as table
code }
  
code {
Table.FromRecords({
     [a = 1, b = 2],
     [a = 3, b = 4]
 }),
code }

  `Table.SelectRows` seems to kind of the equivalent of the → development/databases/SQL `where` clause.
code {
Table.SelectRows(table as table, condition as function) as table
code }
  The following line seems to correspond to `select * from allRows where colXYZ = 'value ABC'`:
code {
selectedRows = Table.SelectRows(allRows, each ([colXYZ] = "value ABC")),
code }
  Compare with `Table.RemoveRows`

  `Table.SelectColumns()` / `Table.RemoveColumns()`
code {
Table.SelectColumns(table as table, columns as any, optional missingField as nullable number) as table
Table.RemoveColumns(table as table, columns as any, optional missingField as nullable number) as table
code }

code {
Table.AddColumn(table as table, newColumnName as text, columnGenerator as function, optional columnType as nullable type) as table
code }

  Add a column named `added` that contains the sum of `val one` and `val two`:
code {
sumAdded = Table.AddColumn(inputTable, "added", each [val one] + [val two], type number),
code }

  Concatenate two text columns:
code {
concatAdded = Table.AddColumn(inputTable, "concatenated", each Text.Combine({[txt one], " ", [txt two]}), type text),
code }

code {
Table.ReorderColumns(table as table, columnOrder as list, optional missingField as nullable number) as table
code }

}
