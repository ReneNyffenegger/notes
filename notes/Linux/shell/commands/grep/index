$ Shell command: grep
@ grep

In its basic use, `grep` prints lines of a text file that match a basic → development/regular-expressions[regular expression].
-
`grep` understands three regular expression dialects: BRE (basic regex), ERE (extended regex) and PCRE (Perl compatible regex), but GNU `grep` does not differentiate between BRE and ERE.
-
The dialect can be chosen with the command line options `-G`, `-E` or `-P`.


The name *grep* originates in `g/re/p` which was a command in → development/editors/qed and → development/editors/ed where a → development/languages/Perl/regular-expressions[regular expression] (`re`) is globally (`g`) search for and matched
text is printed (`p`).

{ Command line options

  table { lll
     `--version` ☰ `-V` ☰ Print version and exit
     `--help` ☰ ☰
     `--extended-regexp` ☰ `-E` ☰
     `--fixed-strings` ☰ `-F` ☰
     `--basic-regexp` ☰ `-G` ☰
     `--perl-regexp` ☰ `-P` ☰
     `--regexp=…` ☰ `-e …` ☰
     `--ignore-case` ☰ `-i` ☰
     `--no-ingore-case` ☰ ☰
     `--invert-match` ☰ `-v` ☰ Print lines where the regular expression does *not* match; don't print lines where it matches.
     `--word-regexp` ☰ `-w` ☰
     `--line-regexp` ☰ `-x` ☰ The regular expression must match the entire line (i. e. as though the regexp were enclosed between `^…$`)
     `--count` ☰ `-c` ☰ Count the number of lines that matched (or didn't match if combined with `-v`)
     `--color=$W` ☰ ☰ `$W` = Use → Linux/shell/ANSI-escape-sequences[escape sequences] to color interesting parts of the output. `$W` is `never`, `always` or `auto`
     `--files-without-match` ☰ `-L` ☰ Instaead of printing matched lines, print the names of the files where no match was found.
     `--files-with-matches` ☰ `-l` ☰ Similar to `-L` but print name of files where at least one match was found.
     `--max-count=N` ☰ `-m N` ☰  Stop processing a file after encountering `N` matches.
     `--only-matching` ☰ `-o` ☰ Print only the portion that was matched by the regular expression.
     `--silent` ☰ `-q` ☰ Print nothing to → development/stdin-stdout-stderr[stdout] (used to query → Linux/kernel/process[process's] exit status)
     `--no-messages` ☰ `-s` ☰  Don't print to stderr(?) if indicated file is inexistent or not readable.
     `--byte-offset` ☰ `-b` ☰ print 0-based byte offset. Compare with `-n`
     `--with-filename` ☰ `-H` ☰ Also print filename where regular expression matched / default when grepping multiple files
     `--no-filename` ☰ `-h` ☰ Opposite of `-H`
     `--label=L` ☰ ☰
     `--line-number` ☰ `-n` ☰ Also print matched line's 1-based line number. Compare with `-b`
     `--initial-tab` ☰ `-T` ☰ Typically used in combination with `-H`, `-n` or `-b`
     `--null` ☰ `-Z` ☰
     `--after-context` ☰ `-A` ☰
     `--before-context` ☰ `-B` ☰
     `--context` ☰ `-C` ☰
     `--group-separator` ☰ ☰
     `--no-group-separator` ☰ ☰
     `--text` ☰ `-a` ☰
     `--binary-files` ☰ ☰
     `--devices=ACTION` ☰ `-D ACTION` ☰
     `--directories=ACTION` ☰ `-d ACTION` ☰ `ACTION` = `read`, `skip` or `recurse`. `-d recurse` is equivalent to `-r`
     `--exclude=GLOB` ☰ ☰
     `--exclude-from` ☰ ☰
     `--exclude-dir` ☰ ☰
     ☰ `-I` ☰
     `--include=GLOB` ☰ ☰
     `--recursive` ☰ `-r` ☰ Process all files under a given directory(-tree). Equivalent to `-d recurse`
     `--dereference-recursive` ☰ `-R` ☰
     `--line-buffered` ☰ ☰
     `--binary` ☰ `-U` ☰
     `--null-data` ☰ `-z` ☰

    

  table }

}

{ Recursive grep

  Only search `*.txt` files:
code {
grep -R --include=*.txt search-pattern
code }

  In → Windows/PowerShell, a recursive grep might be achieved with a combination of → Windows/PowerShell/command-inventory/noun/string/select#select-string-recursively[`select-string` and `get-childItem`].

}
{ -P #grep-P

  With the `-P` flag, the pattern is interpreted as a
  → development/languages/Perl/regular-expressions[Perl-compatible regular expression (PCRE)].

  The default is to interpret is as *basic regular expression* (BRE).

  For example, to match a digit with BRE, you'd use `[0-9]`, with pcre, `[0-9]` as well as `\d` is possible.
  -
  To match three consecutive numbers, the curly braces must be escaped with backslashes: `[0-9]\{3\}`. With pcre, they don't: `\d{3}`.


}
{ Print matched part, not entire line

  With `-o` (or `--only-matching`), only the matched part of a line is printed (as opposed to the entire line that contains the matched text).

  If the mattern matches multiple times per line, each match is printed

  So, the following prints the words in a (text-)file:

code {
grep -oP '\w+' file.txt
code }

}
{ Print lines around matched line #grep-ABC

  `-An` prints the matched line and the `n` lines following it.

  `-Bn` prints the matched line and the `n` lines preceeding it.

  `-cn` prints the matched line and the `n` lines preceeding and following it.

}
{ Searching multiple patterns at once

code {
$ grep -e PatternOne -e PatternTwo -e PatternThree file
code }

Find lines that match any of `PatternOne`, `PatternTwo` or `PatternThree`.

}
{ Searching for hexadecimal values

With → Linux/shell/bash/quoting/index#bash-ansi-c-quoting[ansi c quoting] (`$'...'`), it is possible to search for hexadecimal values. This is not a feature
of grep, but of the shell from which it is invoked.

The following example searches the → development/Unicode/UTF-8[utf 8] representation of `é`:

code {
$ grep $'\xc3\xa9' some-file
code }

}
{ Binary file ... matches

  Apparently, `grep` considers a file with a `NUL` character a binary file and won't by default print matched text for such files.

  In order to still print matches, one can use `-a` or the equivalent `--text` or still `--binary=text`.

}

sa:
  → tools/ack, a grep like tool, optimized for programmers.

  → Linux/shell/commands/index[Shell commands]

  → development/languages/Perl/functions/grep

  → development/version-control-systems/git/commands/grep

  → Linux/shell/bash/variables/regular-expressions[Bash: regular expressions]

  The → development/languages/R/functions/grep[R function `grep`].

  → Windows/dirs/Windows/System32/find_exe, → Windows/dirs/Windows/System32/findstr_exe
  -
  The → Windows/PowerShell equivalent for `grep` seems to be the → Windows/PowerShell cmdLet → Windows/PowerShell/command-inventory/noun/string/select[`select-string`].

  `grep` might be considered a → science/computer/Programming-paradigm/Functional-programming/First-class-function/filter[filter] operation as known in
  → science/computer/Programming-paradigm/Functional-programming[functional programming].

  → https://pdfgrep.org/[pdfgrep] is a commandline utility to search text in PDF documents. This utility tries to be compatible with `grep`.
