$ arch/x86/boot/bzImage

`arch/x86/boot/bzImage` is a *disk-image* file that is built with the following command:
code {
→ Linux/kernel/source/arch/x86/boot/tools/build → Linux/kernel/source/arch/x86/boot/setup_bin → Linux/kernel/source/arch/x86/boot/vmlinux_bin → Linux/kernel/source/arch/x86/boot/zoffset_h → Linux/kernel/source/arch/x86/boot/bzImage 
code }

`bzImage` is a (partly) compressed version of the kernel image. The `bz` of `bzImage` stands for *big zimage*. The content of `bzImage` can be extracted with `→ Linux/kernel/source/scripts/extract-vmlinux`.

{ Masquerading as a PE/COFF image

  A kernel `zImage` or `bzImage` can masquerade as a PE/COFF image on order to convince EFI firmware loaders to load it as an EFI executable.

  A PE/COFF image starts with `MZ`. The following command verifies that this is the case with `bzImage`:
code {
$ echo $(→ Linux/shell/commands/head -c 2 arch/x86/boot/bzImage)
MZ
code }

  At position 0x38 (=56 in decimal), we find the value of the macro → https://github.com/torvalds/linux/blob/633b47cb009d09dc8f4ba9cdb3a0ca138809c7c7/include/linux/pe.h#L35-L40[`LINUX_PE_MAGIC`]:
code {
$ → Linux/shell/commands/xxd -s 56 -l 4 -p  arch/x86/boot/bzImage
cd238281
code }

  TODO: It seems that `CONFIG_EFI_STUB` must be enabled in order for `bzImage` to be a PE/COFF file.

}
{ Copying bzImage to the ESP

 `arch/x86/boot/bzImage` is intended to be copied to the EFI System Partition (ESP) and renamed `.efi`. (Without this extension, the EFI firmware loader refuses to execute it).

  { Pasing arguments to bzImage.efi

  In the EFI shell, it's possible to pass arguments to the kernel via `bzImage.efi` like so:
code {
fs0:> bzImage.efi console=ttyS0 root=/dev/sda4
code }

    The only argument that is consumed by `bzImage.efi` (and not passed to the kernel) is `initrd`.

  }

}
{ Decompressing the kernel #bzImage-decompress

  If the kernel is not relocatable (`CONFIG_RELOCATABLE=n`) then
 `bzImage` will decompress itself to above the address specified with → Linux/kernel/source/arch/x86/include/asm/boot_h#linux-LOAD_PHYSICAL_ADDR[`LOAD_PHYSICAL_ADDR`],
  otherwise, it will be be run from the address where it has been loaded by the boot loader.

}
{ TODO

  { Extract some fields from bzImage

code {

# file=arch/x86/boot/setup.bin
file=arch/x86/boot/bzImage

read_chars() {
   pos=$1
   len=$2
   echo $(dd if=$file bs=1 skip=$(( 16#$pos )) count=$len 2>/dev/null) # expected HdRS

}

read_hex_bytes() {
   pos=$1
   len=$2

   echo $(od --skip-bytes=$(( 16#$pos )) --read-bytes=$len --format=x$len  --address-radix=n $file)
}

echo "MS Dos Header"
echo "  MZ:                        $(read_chars     000 2)"



# include/linux/pe.h: 
#   LINUX_PE_MAGIC appears at offset 0x38 into the MS-DOS header of EFI bootable
#   Linux kernel images that target the architecture as specified by the PE/COFF
#   header machine type field.
#
echo "  LINUX_PE_MAGIC:              $(read_hex_bytes 38 4 )" # expected 818223cd

echo "  Address PE Header:           $(read_hex_bytes 3c 4)"        # Likely to be 82.
echo "  PE_MAGIC:                    $(read_hex_bytes 82 4)" # expected PE\0\0 (see include/linux/pe.h)

echo
echo "PE File Header (coff_header)"  
echo "  Machine:                     $(read_hex_bytes 84 4)" # expected IMAGE_FILE_MACHINE_AMD64 (= 8664) or IMAGE_FILE_MACHINE_I386

echo "  NumberOfSections:            $(read_hex_bytes 88 4)" 
echo
echo "  TimeDateStamp:               $(read_hex_bytes 8a 4)"
echo "  PointerToSymbolTable:        $(read_hex_bytes 8e 4)"
echo "  NumberOfSymbols:             $(read_hex_bytes 92 4)"
echo "  SizeOfOptionalHeader         $(read_hex_bytes 96 2)"
echo "  Characteristics              $(read_hex_bytes 98 2)"  # 0206 = IMAGE_FILE_EXECUTABLE_IMAGE | IMAGE_FILE_DEBUG_STRIPPED | IMAGE_FILE_LINE_NUMS_STRIPPED
echo

echo "PE Optional Header"
echo "  Magic:                       $(read_hex_bytes 9a 2)" # 0x020b = PE_OPT_MAGIC_PE32PLUS
echo "  MajorLinkerVersion:          $(read_hex_bytes 9c 1)" # expected 0x02
echo "  MinorLinkerVersion:          $(read_hex_bytes 9d 1)" # expected 0x14

echo
echo "  SizeOfCode:                  $(read_hex_bytes 9e 4)" # ?
echo "  SizeOfUninitializedData:     $(read_hex_bytes a2 4)"
echo "  SizeOfInitializedData:       $(read_hex_bytes a6 4)"

echo
echo "  AddressOfEntryPoint:         $(read_hex_bytes aa 4)"
echo "  BaseOfCode:                  $(read_hex_bytes ae 4)" # Expected 0x0200 See header.S

echo "  ImageBase:                   $(read_hex_bytes b2 8)" # Expected 1000000 = LOAD_PHYSICAL_ADDR + 0xffff) & ~0xffff  ( See arch/x86/include/asm/boot.h )

echo
echo "  SectionAlignment:            $(read_hex_bytes ba 4)" # Expected 20
echo "  FileAlignment:               $(read_hex_bytes be 4)" # Expected 20

echo
echo "  MajorOperatingSystemVersion: $(read_hex_bytes c2 2)" #
echo "  MinorOperatingSystemVersion: $(read_hex_bytes c4 2)" #

echo
echo "  MajorImageVersion:           $(read_hex_bytes c6 2)" # expected: 3 = LINUX_EFISTUB_MAJOR_VERSION
echo "  MinorImageVersion:           $(read_hex_bytes c8 2)" # expected: 0 = LINUX_EFISTUB_MINOR_VERSION

echo
echo ".setup:                        $(read_chars     13a 6)"
echo "  startup_{32,64}:             $(read_hex_bytes 146 4)"

echo "  size init data on disk       $(read_hex_bytes 14a 4)"
echo "  startup_{32,64}:             $(read_hex_bytes 14c 4)" # ????

echo "  PointerToRelocations:        $(read_hex_bytes 150 4)"
echo "  PointerToLineNumbers:        $(read_hex_bytes 154 4)"
echo "  NumberOfRelocations:         $(read_hex_bytes 158 2)"
echo "  NumberOfLines:               $(read_hex_bytes 15a 2)"

echo
echo "  Characteristics              $(read_hex_bytes 15e 4)" # IMAGE_SCN_CNT_CODE	| IMAGE_SCN_MEM_READ| IMAGE_SCN_MEM_EXECUTE	| IMAGE_SCN_ALIGN_16BYTE

echo
echo ".reloc                         $(read_chars     162 6)"
echo ".text:                         $(read_chars     1b2 5)"

echo "  setup_sects                  $(read_hex_bytes 1f5 1)"
echo "  root_flags:                  $(read_hex_bytes 1f6 2)"
echo "  syssize:                     $(read_hex_bytes 1f8 4)"
echo "  rootdev:                     $(read_hex_bytes 1fc 2)"
echo "  boot_flag:                   $(read_hex_bytes 1fe 2)" # expected aa55

echo "  jump:                        $(read_hex_bytes 200 1)" # expected eb (Assembler JMP instruction)
echo "  header:                      $(read_chars     202 4)" # expected HdRS
echo "  version:                     $(read_hex_bytes 206 4)" # 20f (or so)
echo "handover_offset:         $(od --skip-bytes=612          --read-bytes=4 --format=x4  --address-radix=n $file)"
echo "kernel_info_offset:      $(od --skip-bytes=616          --read-bytes=4 --format=x4  --address-radix=n $file)"
code }

  }

}


sa:

  → https://github.com/torvalds/linux/blob/0e945134b680040b8613e962f586d91b6d40292d/Documentation/admin-guide/efi-stub.rst[`Documentation/admin-guide/efi-stub.rst`] says that 

 `→ Linux/kernel/compilation/make bzImage`

 `→ Linux/kernel/source/arch/x86/boot/tools/build_c`

  The config option `CONFIG_EFI_STUB` allows a bzImage to be loaded directly by EFI firmware without the use of a bootloader.
