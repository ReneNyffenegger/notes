$ include/linux/linkage.h


{ Assembler annotations

 `SYM_FUNC_*` macros annotate functions with standard C calling conventions.
  -
 `objtool` can then ensure that such marked functions conform to the expected rules and annotate these functions with
  debugging information like *ORC data* automatically.

 `SYM_CODE_*` annotes functions with a special stack, for example
   • interrupt handlers,
   • trampolines
   • startup functions

 `SYM_DATA_*` marks data in `.data` (not `.text`) sections so that the tools don't treat the bytes as instructions or assign debugging information
  to them.

  See also `Documentation/core-api/asm-annotations.rst`.

}
{ asmlinkage #linux-asmlinkage

 `asmlinkage` is defined to be `CPP_ASMLINKAGE`:
code {
#define asmlinkage CPP_ASMLINKAGE
code }

 `asmlinkage` is used (among others?) for syscall → Linux/kernel/source/include/linux/syscalls_h#linux-syscall-prototypes[function prototypes] and implementations (such as for example → Linux/kernel/source/init/main_c#linux_start_kernel[`start_kernel`]).

  `CPP_ASMLINKAGE` is defined to be *nothing* in the case C (and to be `extern "C"`) in the case of C++:
code {
#ifdef __cplusplus
#define CPP_ASMLINKAGE extern "C"
#else
#define CPP_ASMLINKAGE
#endif
code }

  I am really not sure if C++ is ever used when compiling the Kernel?

  See also `→ Linux/kernel/source/arch/x86/include/asm/linkage_h`

}
