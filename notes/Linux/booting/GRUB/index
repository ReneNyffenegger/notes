$ GRUB
wp:GNU_GRUB

GRUB stands for *Grand Unified Bootloader*. It is
arguably the most flexible →development/boot-loader for → Linux.
-
Other Linux boot loaders are → Linux/booting/SYSLINUX and → Linux/booting/LILO.

GRUB can not only load Linux but other Operating Systems as well.

The main requirement for GRUB is to adhere to the *Multiboot Specification*.

Because GRUB understands filesystems and kernel image formats, it can load a kernel by just specifying its filename, drive and partition (as opposed to specifying the
physical address).

Except an odd specialised exception, GRUB has only code to read from filesystems in order to to assure users that GRUB cannot be responsible for filesystem corruption.



→ Linux/fhs/usr/lib/grub/_cpu_-_platform_[image directory] (s.a. → Linux/booting/GRUB/image-files).

{ GRUB Legacy vs GRUB 2

  There are two versions of GRUB:
    • GRUB Legacy (also referred to as GRUB 1)
    • GRUB 2

  Both of these versions can be referred to as GRUB, making it impossible to distinguish between them by name only.

  Development on GRUB Legacy has halted. GRUB 2 should be used.

}

{ Installing GRUB

  GRUB is usually installed into the → hardware/harddisk/MBR[MBR], using `→ Linux/shell/commands/grub-install`, for example `grub-install → Linux/fhs/dev/sdX[/dev/sda]`.

}
{ Bootloader

  GRUB's bootloader apparently loads → Linux/fhs/boot/grub/i386-pc/boot_img, then `→ Linux/fhs/boot/grub/i386-pc/core_img`, then
 `→ Linux/fhs/boot/grub/grub_cfg` and then the necessary `*.mod` files (under `→ Linux/fhs/boot/grub/i386-pc`).

}
{ Naming conventions

  A device is recognized by a name in paranthes, for example `(hd1)`.
  -
  The name of first hard disk is `hd0`, the name of the the second is `hd1` etc.

  Partitions are separated from the drive name by a comma, for example `(hd1,msdos3)` or `(hd0,gpt4)`.

  A file is specfied like so: `(hd0,gpt4)/boot/vmlinuz`.

  Grub does not distinguish SATA and IDE when counting the drive numbers.

}
{ Two boot methods

  GRUB boots either
  • the OS directly, or
  • it uses *chain-load* which loads another → Linux/booting/boot-loader[boot loader].

   Chain loading is only supported on PC BIOS and EFI platforms. 
   -
   Autogenerating config files for multi-boot environments depends on os-prober and has several shortcomings. 

}

{ Windows

  GRUB cannot directly boot Windows, it needs the *chain-load* mechanism.

}

{ TODO

  Partition numbers start with 1.

?`save_env` and `load_env` (in `grub.cfg`?) combined with the `grub-editenv` command make it possible to store a small amount of data accross reboots.

  Stanza

  { EFI systems

    On EFI systems with «fixed disk install», the EFI system partition must be mounted to `/efi` before executing `grub-install`.
   
    If the EFI system partition is mounted to a different directory (for example `/mnt/efi`), it needs to be specfied:
code {
grub-install --efi-directory=/mnt/efi
code }

  }
  { Booting an OS

    { Directly

      An OS can be booted directly with the `boot` command.

    }
    { Chain loading an OS

      An OS such as Windows must be chain loaded.
code {
menuentry "Windows" {
	insmod       chain
	insmod       ntfs
	set          root=(hd0,1)
	chainloader +1
}
code }

    }

  }
  { Reserving a partition for GRUB (BIOS boot partition)

    It's possible to reserve a partition (the BIOS boot partition) for GRUB.
    -
    Putting GRUB on this partition reduces the risk for it to be overwritten.

    This partition requires the correct partition type (bios_grub):
code {
parted /dev/… set partition-number bios_grub on
code }

  }
  { GRUB shell

?   The GRUB shell is caused to start by pressing `c` when GRUB is started.
    -
    I also had it started with executing `grub-install` but without `grub-mkconfig`.

code {
   Minimal BAHS-like editing is supported. For the first word, TAB lists possible command completions. Anywhere else TAB lists possible device or file completions.

grub> ls
(proc) (hd0) (hd0,gpt6) (hd0,gpt5) (hd0,gpt4) (hd0,gpt3) (hd0,gpt2) (hd0,gpt1)
grub> ls (hd0,gpt1)
        Partition hd0,gpt1: Filesystem type fat, UUID BC6a-B14F - Partition start at 1024KiB - Total Size 102400KiB
grub> ls (hd0,gpt1)/
efi/ System Volumen Information
grub> ls -l (hd0,gpt1)
DIR          20230810202914 efi/
DIR          20230515092630 System Volume Information/

grub> ls -l (hd0,gpt6)/boot
12046688     20230810202558 vmlinuz
…
grub> set root=(hd0,gpt6)
grub> linux /boot/vmlinuz
grub> boot
error:  no suitable video mode found.
Booting in blind mode
code }

    In order to get around the *no suitable video mode found.* error, execute the same sequence of command, but add `insmod all_video` before calling `boot`.

  }
  { Source files, development etc.

    GRUB uses Autoconf and Automake. Input for Automake is mostly generated by a Python script.

    table { lll
      `grub-core/` ☰   ☰ Contains code that is run at boot time (as opposed to code being run within an operating system located in the top level directory)
      `grub-core/boot/` ☰ Low level code  ☰ For example the MBR implementation for PC BIOS systems.
      `grub-core/kern/` ☰ The grub kernel ☰ Functionality handling devices, disks, files, environment variables etc.
      `grub-core/term/` ☰ Terminal functionality ☰
      `grub-core/disk/` ☰ Disk access ☰
      `grub-core/partmap/` ☰ Reading partition tables ☰
      `grub-core/fs/` ☰ Access filesystems ☰
      `grub-core/bus/` ☰ PCI and USB handling ☰
      `grub-core/video/` ☰ Video handling ☰
      `grub-core/gfxmenu/` ☰ Graphical menu ☰
      `grub-core/commands/` ☰ Most commands ☰ There are exceptions and some commands are implemented elsewhere.
      `grub-core/osdep/` ☰ ☰
    table }

    Often, the `_start` symbol is found in assembly files named `startup.S`:
code {
$ → Linux/shell/commands/grep -rlP '\b_start\b'
code }

  }
}

sa:

 `→ Linux/fhs/boot/grub`

 `→ Linux/fhs/boot/grub/grub_cfg` is the configuration file, typically generated by `→ Linux/shell/commands/grub-mkconfig`.

  → Linux/booting/boot-loader[Boot loaders].
