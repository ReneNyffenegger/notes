$ Oracle 23c: New features
@ 23c

rem {
https://twitter.com/ChrisRSaxon/status/1582811221958328320
https://twitter.com/martinberx/status/1644685453998555137
https://twitter.com/martinberx/status/1644722118720991232    select;
https://twitter.com/ludodba/status/1646890710996598784
rem }

Oracle claims that 23c has 300+ new features and enhancements compared to → development/databases/Oracle/Releases-and-versions/21c.

{ BOOLEAN data type in SQL

  Oracle 23c introduces the `→ development/databases/Oracle/SQL/data-types/boolean` → development/databases/Oracle/SQL/data-types[datatype] for
  → development/databases/Oracle/SQL[SQL] (after it having been in → development/databases/Oracle/PL-SQL[PL/SQL] for quite some time).

  Some textual values such as `true`, `false`, `y`, `yes` will be converted to a boolean value, any numerical value that is not 0 will be converted to `true`, 0 values to `false`.

code {
create table tq84_bool_test (val varchar2(10), flg boolean);
insert into tq84_bool_test values ('true'  , true );
insert into tq84_bool_test values ('false' , false);
insert into tq84_bool_test values ('null'  , null );
insert into tq84_bool_test values ('t'     ,'t'   );
insert into tq84_bool_test values ('yes'   ,'yes' );
insert into tq84_bool_test values ('true'  ,'true');
insert into tq84_bool_test values ('f'     ,'f'   );
insert into tq84_bool_test values ('0'     , 0    );

select val from tq84_bool_test where     flg;
select val from tq84_bool_test where not flg;
code }

  The new datatype comes with the function `to_boolean(…)`.

  Oracle clients earlier than 23c will display `true` values as `1` and `false` values as `0`:
code {
SQL> select true, false;
--
-- TRUE FALSE
-- ---- -----
--    1     0
code }


  Trying to use a `boolean` in a release earlier than 23c would result in a → development/databases/Oracle/errors/ORA-00902_invalid-datatype#ora-00902-boolean[ORA-00902: invalid datatype] error message.

}
{ Selecting an expression without FROM DUAL

  The → development/databases/Oracle/SQL/dual[`DUAL` table] is not needed anymore to select one or more expressions:
rem {
 (if `_past_dual_enabled` is set to `true`?):
rem }
code {
select
  'Hello world'     as txt,
   7 * 6            as num,
   sysdate          as now;
code }

}
{ JavaScript Stored procedures

  Stored procedures can be written in → development/languages/JavaScript:
code {
create mle module tq84_js language javascript as

    export function f(p1, p2) { return p1+p2; }
   
    …

  create function f (p1 number, p2 number) return number as mle module tq84_js signature f(number, number);

  select f(20, 22) /* Ha: no more dual :-) */;
code }

}
{ DROP/CREATE TABLE IF [NOT] EXIST

  The `if [not] exist` clause auf the `create table` and `→ development/databases/Oracle/SQL/statement/nouns/table/drop` statements are useful to prevent the
  → development/databases/Oracle/errors/ORA-00942_table-or-view-does-not-exist and *ORA-00955: name is already used by an existing object* errors:

code {
drop   table IF     EXIST tq84_t1;
create table IF NOT EXIST tq84_t2 (num number, txt varchar2(10));
code }

}
{ GROUP BY on expression aliases/position number

 `→ development/databases/Oracle/SQL/select/group-by` can use aliases for expressions (such as the result of a PL/SQL function):
code {
select
   count(*),
   fnc(a, b) xyz
from
   t
group by
   xyz
having
   xyz > 100
;
code }

  Prior to Oracle 23, the previous statement would have thrown a → development/databases/Oracle/errors/ORA-00904_invalid-identifier error message.

  If the `group_by_position_enabled` → development/databases/Oracle/adminstration/init-parameters[init parameter] is set to `true`, it's also possible to group by a position number 
  In order to group on a position *number* (rather than an expression alias):
code {
→ development/databases/Oracle/SQL/statement/nouns/session/set/init-param[alter session] set group_by_position_enabled = true;

select
   category_id,
   sum(val)
from
   t
group by
   1;
code }

}
{ Updating tables

  Tables can be updated with a condition specified in a («direct») → development/databases/Oracle/SQL/join:

code {
udpate    dest d
   set    d.xxx = …
  from    src  s
 where    d.abc = s.def;
code }

}
{ JSON

  { JSON Schema

    A *JSON schema* allows to validate → development/languages/JavaScript/JSON documents:

code {
create table tq84_json_schema_test (
   obj json validate '
     {
         "num": number,
         … 
     }
   '
);
code }
  }
  { JSON Relational Duality

   *JSON Relational Duality* provides a mapping between
      • the way an application consumes and represents data (i. e. JSON documents) and
      • the paradigm in which a *relational* database stores the data (i. e. rows).

    This mapping is defined in *JSON relational duality views*.

?   The conversion is between these two worlds is triggered in/with *GraphQL*.

code {
create or replace JSON DUALITY VIEW
from tq84_root_tab                   -- The name table sitting at the top of the hierarchy
as
   tq84_rel_dual_test
   @update @insert @delete
{
   num      :   col_num,             -- Mapping between JSON property names and table column names
   txt      :   col_txt
   children : tq84_child_tab {       -- Nesting objects
     …

   }
}
code }
    { Accessing duality views

      A duality view can be accessed with
        • SQL
        • traditional → development/web/HTTP[HTTP]/→ development/web/service/REST[REST] operations, i. e. GET, PUT and POST → development/web/HTTP/request-methods[HTTP requests]. (see *concurrent reading/writing access* below)
        • Simple Oracle Document API (SODA)
        • Oracle Database API for MongoDB
        • ORDS

    }
    { Concurrent reading/writing access

      → development/web/service/REST[REST] GET and REST PUT are stateless operations. Thus, a writing operation might overwrite the modification of another writing request («mid-air collision» problem).

      In order to avoid this problem, Oracle has adapted the concept of the *ETag* response and *If-Match* request → development/web/HTTP/header[HTTP header].

    }
    { Advantages over ORM

      Some advantages of duality views over Object Relational Mappings (ORMs) are
        • They're language independent
        • They're optimized by the database

    }
    { Describing a duality view's schema

      `dbms_json_schema.describe('tq84_rel_dual_test')`

code {
$dbHost=…
$schemaName=rene
→ tools/cURL[curl] -X GET http://$dbHost/ords/$schemaName/metadata-catalog/tq84_rel_dual_test
code }

    }
    { Links

      See also → https://twitter.com/ChrisRSaxon/status/1582808508973473793[Chris Saxon's tweet].

    }
  }
}
{ Table value constructors

  Insert multiple records at once (going by the name of «table value constructor»):
code {
insert into t1 values
  (1, 'first record' ),
  (2, 'second record'),
  (3, 'third record' ),
  (4, 'fourth record');
code }

  Similarly in a `select` statement:
code {
select * from (
  values
    (1, 'first record' ),
    (2, 'second record'),
    (3, 'third record' ),
    (4, 'fourth record')
)
tmp (num, txt);
code }

}
{ Schema Level Privileges

  → development/databases/Oracle/security/privileges[Privileges] can be granted on entire schemas:
code {
→ development/databases/Oracle/SQL/DCL/grant
   select any table
on
   schema sales  
to
   rene;
code }

}
{ SQL domains

  SQL domains can optionally specify a
    • data constraint
    • display format
    • a collation

code {
create domain email_addr as varchar2(99);

create domain month_year as varchar2(7)
   constraint month_fmt check (regexp_like(month_year, '^\d\d-\d\d\d\d$'))
   display 'Year: ' || substr(month_year, 4, 4) || ', Month: ' || substr(month_year, 1, 2)
   order substr(month_year, 4, 4) || substr(month_year, 1, 2)
;

create table financial_report (
   id             integer    primary key,
   corrections_to email_addr,
   rep_period     month_year,
   pdf            blob
);

insert into financial_report values
( 1, 'fred@xyz.ab', '03-2023', null ),
( 2, 'fred@xyz.ab', '08-2023', null ),
( 3, 'maya@xyz.ab', '02-2023', null ),
( 4, 'joey@xyz.ab', '06-2023', null );
code }

  The `order` clause of the `month_year` domains influences the sort order of `order by` so that it is sorted logically rather than by the by the displayed value:
code {
select
   rep_period,
   corrections_to,
   id
from
   financial_report
order by
   rep_period;
--
-- REP_PER CORRECTIONS_TO         ID
-- ------- -------------- ----------
-- 02-2023 maya@xyz.ab             3
-- 03-2023 fred@xyz.ab             1
-- 06-2023 joey@xyz.ab             4
-- 08-2023 fred@xyz.ab             2
code }

 `domain_display(…)` applies the display rules when selecting values from a domain:
code {
select
   domain_display(rep_period) repper,
   corrections_to
from
   financial_report
order by
   rep_period;

-- REPPER                CORRECTIONS_TO                                                                                     
-- --------------------- ---------------------------------------------------------------------------------------------------
-- Year: 2023, Month: 02 maya@xyz.ab                                                                                        
-- Year: 2023, Month: 03 fred@xyz.ab                                                                                        
-- Year: 2023, Month: 06 joey@xyz.ab                                                                                        
-- Year: 2023, Month: 08 fred@xyz.ab                                                                                        
code }

  Domains are stored in the data dictionary in `dba_domains` etc.


}
{ Developer role

  A special developer role (named `db_developer_role`) can be granted to facilitate developers's jobs.
code {
begin
   dbms_developer_admin.grant_privs('rene');
end;
/
code }
  *2023-04-10*: Apparently, `dbms_developer_admin` is not present in (at least the) Oracle 23c Free edition.

code {
SQL> → development/databases/Oracle/SQL/DCL/grant db_developer_role to rene identified by renesSecretPassword;
grant succeeded.

SQL> connect rene/renesSecretPassword@ora23c;
connected.

SQL> → development/databases/Oracle/SQL/select * from → development/databases/Oracle/installed/data-dictionary/session/privs order by privilege;
PRIVILEGE
------------------------------
CREATE ANALYTIC VIEW
CREATE ATTRIBUTE DIMENSION
CREATE CUBE
CREATE CUBE BUILD PROCESS
CREATE CUBE DIMENSION
CREATE DIMENSION
CREATE DOMAIN
CREATE HIERARCHY
CREATE JOB
CREATE MATERIALIZED VIEW
CREATE MINING MODEL
CREATE MLE
CREATE PROCEDURE
CREATE SEQUENCE
CREATE SESSION
CREATE SYNONYM
CREATE TABLE
CREATE TRIGGER
CREATE TYPE
CREATE VIEW
DEBUG CONNECT SESSION
EXECUTE DYNAMIC MLE
FORCE TRANSACTION
ON COMMIT REFRESH

24 rows selected.
code }

  The `db_developer_role` is created in `→ Linux/fhs/u01/app/oracle/product/vv-v-v/dbhome_n/rdbms/admin/catdevrol_sql` (in which script also the corresponding
  → development/databases/Oracle/security/privileges[privileges] are granted).

}
{ Up to 4096 columns per table

  Up to 4096 → development/databases/Oracle/objects/tables/columns[columns] per → development/databases/Oracle/objects/tables (requires `max_columns` to be set to `extended` and `compatibility` to be set to `23.0.0`).

}
{ Object and schema annotations 

  Key value pair annotations for (some) → development/databases/Oracle/objects[objects] provide metadata for data and schema.

code {
create table t_foo ( … )
annotations (
   expected_release 'R4.2',
   test_coverage    'no'
);
code }

  Annotations are supported for tables, views, materialized views, columns, indexes and domains.

  Annotations can be queried in the data dictionary:
code {
select * from user_annotations;
select * from user_annotation_values;
select * from user_annotations_usage;
code }

}
{ «Asynchronous» transactions (lock-free reservations)

  A *numeric* column that is marked *reservable* allows multiple transactions to concurrently update the value.

  The following example creates such a table and inserts some test data:
code {
create table tq84_async (
    id    integer     primary key,
    val   number(5,2) RESERVABLE
);

insert into tq84_async values
(  13,   18.22 ),
(  19,    7.83 ),
(  42,  100.00 ),
(  99,   68.54 );

commit;
code }

  A session updates a record in this table and then queries the value (which does not seem to change, i.e. is still 100):
code {
SES 1> update tq84_async set val = val + 10 where id = 42;
SES 1> select * from tq84_async where id = 42;
--
--         ID        VAL
-- ---------- ----------
--         42        100
code }


  Another session also updates `val` (while the first session has not commited the update). This session also sees the value of 100:
code {
SES 2> update tq84_async set val = val +  1 where id = 42;
SES 2> select * from tq84_async where id = 42;
--
--         ID        VAL
-- ---------- ----------
--         42        100
code }

   The first session then commits its transaction. It now sees its modification:
code {
SES 1> commit;
SES 1> select * from tq84_async where id = 42;
--
--         ID        VAL
-- ---------- ----------
--         42        110
code }

  The second session also sees the update of the first session but still not its own update:
code {
SES 2> select * from tq84_async where id = 42;
--
--         ID        VAL
-- ---------- ----------
--         42        110
code }

  Only when the 2nd session commits its transaction, its modification becomes visible also:
code {
SES 2> commit;
SES 2> select * from tq84_async where id = 42;
--
--         ID        VAL
-- ---------- ----------
--         42        111
code }

  After the commit in the second session, the first session commits also and then selects the updated record:
code {
SES 1> commit;
SES 1> select * from tq84_tab;
       ID        VAL
---------  ---------
       42        111
code }

  A table with a reservable column cannot be dropped (error message *ORA-55764: Cannot DROP or MOVE tables with reservable columns*). Thus, the column must be first set to `not reservable`:
code {
alter table tq84_async modify val not reservable;
drop  table tq84_async;
code }

  { See also

    See also *Connor McDonald's* → https://twitter.com/connor_mc_d/status/1588432563638796288[tweet] and the follow up on
    → https://www.youtube.com/watch?v=oO3yrdU7w18[YouTube].

  }
}
{ Improved error messages #ora-23c-err

  A program of Oracle (that is not strictly related to 23c only) tries to improve → development/databases/Oracle/errors[error messages]:
code {
ORA21> select sum(val), gr_1, gr_2 from T group by gr_1;
→ development/databases/Oracle/errors/ORA-00979_not-a-GROUP-BY-expression

ORA21> → development/databases/Oracle/SQL-Plus/connect …@ORA23

ORA23> select sum(val), gr_1, gr_2 from T group by gr_1;
ORA-00979: "GR_2": must appear in the GROUP BY clause or
                   be used in an aggregate function
code }


}
{ Misc

  Further improvements might (or do?) include:
  • Improved `returning` clause for `merge` and `update` statements (See → https://db-oriented.com/2017/10/07/returning-into-enhancement-suggestion/[this enhancment suggestion] and → https://community.oracle.com/tech/apps-infra/discussion/4396106/returning-into-support-both-pre-update-and-post-update-values[this Oracle community discussion]).
  • → development/databases/Oracle/SQL/select/aggregate[Aggregation] over `interval` data types
  • Enhancements for blockchain tables
  • SQL <-> PL/SQL transpiler
  • 1024 byte passwords
  • OJM allows HTTP and TCP access while other OS calls are disabled
  • Sagas for microservices / Lock-free reservations
  • Transparent application continuity
  • Ubiquitous search with `dbms_search`
  • Asynchronous programming
  • SQL Property Graph Query Language (ISO SQL/PQL standard)
  • `default on null` for `update` statements
  • True Cache
  • Real-time SQL Plan Management
  • Read-only Per-PDB Standby
  • In-database SQL firewall
  • OKafka
  • Oracle text indexes with automatic maintenance
  • Transportable binary → development/XML
  • OAuth 2.0 integration
  • On OCI: Oracle Database Zero Data Loss Autonomous Recovery Service (with which Oracle hopes to address the challenges of ransomware, outages and human errors)
  • On OCI: Oracle Full Stack Disaster Recovery Service (Configuration, monitoring and management of the disaster recovery process for the *full stack* of technologies, including middleware, databases, networks, storage)
  • Support for Unicode Ideographic Variation Sequences (IVS)

}
{ Docker image

  There is a docker image for the free edition of Oracle 23c:
code {
docker pull container-registry.oracle.com/database/free
code }

  However, this image is poorly (if at all) documented, thus I had to make a few dabbles in the dark to get it running usefully.

  Start a new container:
code {
docker run -d -p 1521:1521 container-registry.oracle.com/database/free
code }

  Check the status of the container until it changes from *Up … seconds (health: starting)* to *Up 2 minutes (healthy)*:
code {
docker ps
code }

  When it is running, I opened a shell in the container:
code {
docker exec -it dreamy_heisenberg bash
code }

  In this shell, I could run SQL*Plus and change the password for SYS:
code {
bash-4.4$ sqlplus / as sysdba
…
SQL> alter user sys identified by IamTheDBA;

User altered.
code }

  With this password, I could then connect to the instance from SQL Developer using the service names *FREE* and *FREEPDB1*.

  It should be noted that all changes to the database disappear when the docker container is stopped.

rem {
SYS_PW=IAmTheDBA
ORA_USER=rene
ORA_PW=IAmTheUser
docker run -d -p 1521:1521 -e ORACLE_PASSWORD=$SYS_PW -e APP_USER=$ORA_USER -e APP_USER_PASSWORD=$ORA_PW                                      container-registry.oracle.com/database/free # gvenzl/oracle-free
docker run -d -p 1521:1521 -e ORACLE_PASSWORD=$SYS_PW -e APP_USER=$ORA_USER -e APP_USER_PASSWORD=$ORA_PW -v oracle-volume:/opt/oracle/oradata container-registry.oracle.com/database/free # gvenzl/oracle-free
rem }

}
{ Oracle Database 23c Umbrella Beta Program

  The *Oracle Database 23c Umbrella Beta Program* gives its participants (i.e. beta testes) access to these new features before they are released.

  Companies wanting to participate must meet the following minimal criterias:  
    • If applying as an Oracle Customer, the company holds an active license or subscription for the product being offered for beta testing.
    • If applying as an Oracle Partner, the company is an active member of the Oracle PartnerNetwork and is enrolled in the appropriate track
    • The Company has achieved the appropriate expertise level in the product available for beta testing.
    • From the Oracle ACE Program, only ACE Directors are eligible to participate in beta programs.
    • Authors must have a book contract with an Oracle Publisher Program member.

  This beta program is estimated to last from October 2022 through February 2023 and can be  → https://bit.ly/OracleBetaTesting[signed up here].

}

links:
  Philipp Salvisberg's → https://twitter.com/phsalvisberg/status/1572885995070300160[Twitterthread] summarizes some impressions from new 23c features presented at the DOAG 2022 Conference.


  That Jeff Smith's → https://threadreaderapp.com/scrolly/1582788029269168128[notes]
