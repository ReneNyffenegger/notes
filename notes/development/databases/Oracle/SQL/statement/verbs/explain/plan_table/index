$ Oracle: PLAN_TABLE

`plan_table` is used by the SQL statement  → development/databases/Oracle/SQL/statement/verbs/explain[`explain plan`] to write its result to.

code {
create table PLAN_TABLE /* sharing=none */  (
        statement_id       varchar2(30)  ,
        plan_id            number        ,  -- Uniquely identifies a plan (not a record)
        timestamp          date          ,
        remarks            varchar2(4000),
        operation          varchar2(30)  ,  -- … 
                                            -- If id = 0 (first row in plan): operation indicates the
                                            -- SQL statement type: DELETE STATEMENT, MERGE STATEMENT, SELECT STATEMENT, INSERT STATEMENT,
                                            -- CREATE TABLE STATEMENT or CREATE INDEX STATEMENT
        options            varchar2(255) ,  -- 
        object_node        varchar2(128) ,  -- Name of database link or for parallel queries order in which output from operation is consumed
        object_owner       varchar2(128) ,
        object_name        varchar2(128) ,  -- "TABLE", "TABLE (TEMP)", "NON-UNIQUE" etc.
        object_alias       varchar2(261) ,
        object_instance    numeric       ,  -- Ordinal position of object as found in SQL statement (left to right, outer to inner). View expansion number is unpredictable.
        object_type        varchar2(30)  ,
        optimizer          varchar2(255) ,  -- "ALL_ROWS", "ANALYZED", …
        search_columns     number        ,  -- Number of index columns that can be used to match a predicate, that is: the number of index columns with start and stop keys.
        id                 numeric       ,
        parent_id          numeric       ,
        depth              numeric       ,
        position           numeric       ,  -- First row (id = 0): estimated cost (and equal to value in cost, see also → development/databases/Oracle/installed/dynamic-performance-views/sql/plan#vSsql-plan-position[here]). Other rows: relative position of children with same parent
        cost               numeric       ,  -- cost = F(cpu_cust, io_cost)
        cardinality        numeric       ,
        bytes              numeric       ,
        other_tag          varchar2(255) ,
        partition_start    varchar2(255) ,
        partition_stop     varchar2(255) ,
        partition_id       numeric       ,
        other              long          ,
        distribution       varchar2(30)  ,
        cpu_cost           numeric       ,
        io_cost            numeric       ,
        temp_space         numeric       ,
        access_predicates  varchar2(4000),  -- Predicates that are used to locate rows, for example as start/stop predicates in an index range scan.
                                            -- Only operations where access_predicates is filled seem to be INDEX, CONNECT BY, HASH JOIN and SORT
        filter_predicates  varchar2(4000),  -- Predicates that are used to filter rows
        projection         varchar2(4000),
        time               numeric       ,
        qblock_name        varchar2(128) ,  -- Name of query block (either generated or specified with QB_NAME hint)
        other_xml          clob
);
code }

{ qblock_name #plan_table-qblock_name

  If not specified with a → development/databases/Oracle/SQL/hints[hint], the first four characters of `qblock_name` reveals the type of the SQL statement:
    • `SEL$`
    • `DEL$`
    • `INS$`
    • `UPD$`
    • `MRG$` 
    • `CRI$` (`create index`)
    • `SET$` (Apparently used in sort operations, `union all` clauses, selecting from underlying views, → development/databases/Oracle/SQL/statement/execution/parallel[parallel query] coordination etc.)

  As per → https://sqlmaria.com/2020/03/10/what-are-query-block-names-and-how-to-find-them/[SQLMaria (Maria Colgan)], there is also `MISC$`.

  See also the → development/databases/Oracle/SQL/hints#ora-hint-4-types[query block SQL hint type].

  Select first and second part from qblock name:
code {
select
   sql_id,
   qblock_name,
   regexp_replace(qblock_name, '^([^$]+)\$[^$]+$', '\1') qblock_name_part_1,
   regexp_replace(qblock_name, '^[^$]+\$([^$]+)$', '\1') qblock_name_part_2
from
   v$sql_plan
;
code }

  { Operations related to SET$

    The following query finds operations that are related to `SET$`:
code {
select   count(*), operation, options
from     v$sql_plan
where    qblock_name like 'SET%'
group by operation, options
order by count(*) desc;
code }

  }

}
{ object_alias

  The value of `object_alias` is either → development/databases/Oracle/SQL/null[`null`] or matches the
  → development/regular-expressions[regular expression] `"[^"]+"@"[^"]+"$`, the following SQL does not return a record (at least I never encountered one):
code {
select count(*) from → development/databases/Oracle/installed/dynamic-performance-views/sql/plan[v$sql_plan] where not regexp_like(object_alias, '"[^"]+"@"[^"]+"$');
code }

?  The second part (after the `@`, which is enclosed in `"…"`) seems to correspond to a qblock name.

code {
select
   object_alias,
--
-- If not using an alias in the SQL statement, the first part of the object alias
-- is equal to the object_name. Note, that object_name can also refer to an index
-- in which case othe first part of the object alias is null:
   regexp_replace(object_alias, '^"([^"]+)"@"[^"]+"$', '\1') object_alias_part_1,
   object_name,
 
--
-- Often, the second part of the object alias is equal to the qblock_name (
-- especially if qblock_name is not using the hash-semantics (SEL$12EC7C91):
   regexp_replace(object_alias, '^"[^"]+"@"([^"]+)"$', '\1') object_alias_part_2,
   qblock_name,
-- -----
   object_type,
   operation
-- v$sql_plan.*
from
   v$sql_plan;
code }

}
{ access_predicates

code {
select
   count(*),
   operation
-- options
from
   v$sql_plan
where
   access_predicates is not null
group by
    operation
--  options
order by
   count(*) desc;
--
-- INDEX
-- HASH JOIN
-- CONNECT BY
-- SORT
-- BITMAP INDEX
-- TABLE ACCESS
code }

}
{ other_xml

code {
<other_xml>
  <info type="derived_cpu_dop">1</info>
  <info type="derived_io_dop">2</info>
  <info type="dop_reason" note="y">parallel threshold</info>
  <info type="dop" note="y">1</info>
  <info type="px_in_memory_imc" note="y">no</info>
  <info type="px_in_memory" note="y">no</info>
  <info type="xml_suboptimal" note="y">yes</info>
  <info type="db_version">19.0.0.0</info>
  <info type="parse_schema"><![CDATA["RENE"]]></info>
  <info type="dynamic_sampling" note="y">2</info>
  <info type="plan_hash_full">2554717464</info>
  <info type="plan_hash">1584358665</info>
  <info type="plan_hash_2">2554717464</info>
  <qb_registry>
    <q o="18" f="y" h="y">
      <n><![CDATA[SEL$F5BB74E1]]></n>
      <p><![CDATA[SEL$1]]></p>
      <i>
        <o> <t>VW</t> <v><![CDATA[SEL$2]]></v> </o>
      </i>
      <f>
        <h> <t><![CDATA[P]]></t> <s><![CDATA[SEL$1]]></s> </h>
        <h> <t><![CDATA[KOKBF$0]]></t> <s><![CDATA[SEL$2]]></s> </h>
     </f>
  </q>
  <q o="2">
    <n><![CDATA[SEL$1]]></n>
    <f>
      <h> <t><![CDATA[H]]></t> <s><![CDATA[SEL$1]]></s> </h>
      <h> <t><![CDATA[P]]></t> <s><![CDATA[SEL$1]]></s> </h>
    </f>
  </q>
  <q o="2">
    <n><![CDATA[SEL$2]]></n>
    <f>
      <h> <t><![CDATA[KOKBF$0]]></t> <s><![CDATA[SEL$2]]></s> </h>
    </f>
  </q>
  </qb_registry>
  <outline_data>
    <hint><![CDATA[USE_NL(@"SEL$F5BB74E1" "KOKBF$0"@"SEL$2")]]></hint>
    <hint><![CDATA[LEADING(@"SEL$F5BB74E1" "P"@"SEL$1" "KOKBF$0"@"SEL$2")]]></hint>
    <hint><![CDATA[FULL(@"SEL$F5BB74E1" "KOKBF$0"@"SEL$2")]]></hint>
</qb_registry>
    <hint><![CDATA[OUTLINE(@"SEL$2")]]></hint>
    <hint><![CDATA[OUTLINE(@"SEL$1")]]></hint>
    <hint><![CDATA[MERGE(@"SEL$2" >"SEL$1")]]></hint>
    <hint><![CDATA[OUTLINE_LEAF(@"SEL$F5BB74E1")]]></hint>
    <hint><![CDATA[NO_PARALLEL]]></hint>
    <hint><![CDATA[NO_COST_XML_QUERY_REWRITE]]></hint>
    <hint><![CDATA[XMLINDEX_REWRITE_IN_SELECT]]></hint>
    <hint><![CDATA[XMLINDEX_REWRITE]]></hint>
    <hint><![CDATA[XML_DML_RWT_STMT]]></hint>
    <hint><![CDATA[FORCE_XML_QUERY_REWRITE]]></hint>
    <hint><![CDATA[ALL_ROWS]]></hint><hint><![CDATA[DB_VERSION('19.1.0')]]></hint>
    <hint><![CDATA[OPTIMIZER_FEATURES_ENABLE('19.1.0')]]></hint>
    <hint><![CDATA[IGNORE_OPTIM_EMBEDDED_HINTS]]></hint>
  </outline_data>
</other_xml>
code }

}
