$ Oracle: SQL statement execution plan operations

An → development/databases/Oracle/SQL/statement/execution/plan consists of a series of tree-like nested operations (aka row sources).

There are two types of operations:
  • Operations that retrieve data from a → development/databases/Oracle/architecture/database/files/data (for example → development/databases/Oracle/SQL/statement/execution/plan/operations/table-access/full[`TABLE ACCESS (FULL)`]), or
  • Operations that combine or otherwise manipulate the data that it receives from its child operations (for example `NESTED JOIN`).


table { llll

  ~Operation~ ☰ ~Option~ ☰ ~nof inputs~ ☰ ~Comment~
   ? AND-EQUAL ☰ ☰ ☰
   BITMAP AND ☰  ☰ 2 ☰
   BITMAP CONSTRUCTION ☰ ☰ ☰
   BITMAP CONVERSION ☰ TO ROWIDS ☰ 1 ☰
   ? BITMAP CONVERSION ☰ FROM ROWIDS ☰ ? ☰
   BITMAP CONVERSION ☰ COUNT ☰ ? ☰ Count bits in a bitmap index (`select count(*) from tab;`, `tab` having a bitmap index).
   BITMAP INDEX ☰ FAST FULL SCAN ☰ 1 ☰ Same as `FULL SCAN`?
   ? BITMAP INDEX ☰ RANGE SCAN ☰ ? ☰
   BITMAP INDEX ☰ SINGLE VALUE ☰ 1 ☰
   BUFFER ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/buffer/sort[SORT] ☰ 1 - 2 ☰ In spite of the `SORT` in the name, this operation does not necessarily sort its input, rather it only uses the buffering functionality of a «traditional» sort to store data in the → development/databases/Oracle/architecture/instance/PGA or → development/databases/Oracle/architecture/instance/UGA to reduce full table scans. Compare with `SORT (…)`. See also → http://sadique-sadiqulislam.blogspot.com/2011/01/buffer-sort-reason-and-problems.html[Sadique's blog]
   BUFFER ☰ SORT (REUSE) ☰ 
   COLLECTION ITERATOR ☰ PICKLER FETCH ☰ 1 ☰ Column → development/databases/Oracle/SQL/statement/verbs/explain/plan_table/columns/object_type[`object_type`] in → development/databases/Oracle/SQL/statement/verbs/explain/plan_table[`plan_table`] often set to `PROCEDURE` and `object_owner` and `object_type` set to, for example, `dbms_xplan` and `display`.
   CONCATENATION ☰  ☰ 2 - 3 (?) ☰
   CONNECT BY ☰ NO FILTERING WITH START-WITH ☰ 1 ☰
   CONNECT BY ☰ WITH FILTERING ☰ 2 ☰
   CONNECT BY ☰ WITH FILTERING (UNIQUE) ☰ 2 ☰
   CONNECT BY ☰ WITHOUT FILTERING ☰ 1 - 2 ☰
   CONNECT BY ☰ WITHOUT FILTERING ☰ 2 ☰
   CONNECT BY PUMP ☰  ☰ 1 ☰
   COUNT ☰ ☰ 1 ☰ Created by `rownum`.
   COUNT ☰ STOPKEY ☰ 1 ☰ `rownum` plus criterion (in outer query?)
   COUNT ☰  ☰ 1 ☰
   CREATE TABLE STATEMENT ☰  ☰ 1 - (?) ☰
   DATA LINK ☰ FULL ☰ 1 ☰
   DELETE ☰  ☰ 1 ☰
   DELETE STATEMENT ☰  ☰ 1 ☰
   EXTENDED DATA LINK ☰ FULL ☰ 1 ☰
   FAST DUAL ☰  ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/filter[FILTER] ☰  ☰ 1 - n ☰ Only pass on rows that match criteria. Compare with the plan operation → development/databases/Oracle/SQL/statement/execution/plan/operations/view[`VIEW`] and the  → development/databases/Oracle/SQL/statement/verbs/explain/plan_table/columns/filter_predicates[plan table column `filter_predicates`] of the → development/databases/Oracle/SQL/statement/verbs/explain/plan_table[`plan_table`].
   FIRST ROW ☰  ☰ 1 ☰
   FIXED TABLE ☰ FIXED INDEX ☰ 1 ☰
   FIXED TABLE ☰ FULL ☰ 1 ☰
   FOR UPDATE ☰  ☰ 1 ☰
   HASH ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/hash/group-by[GROUP BY] ☰ 1 ☰
   HASH ☰ UNIQUE ☰ 1 ☰
   HASH JOIN ☰ ANTI ☰ 2 ☰
   HASH JOIN ☰ ANTI NA ☰ 2 ☰
   HASH JOIN ☰ BUFFERED ☰ 2 ☰
   HASH JOIN ☰ FULL OUTER ☰ 2 ☰
   HASH JOIN ☰ OUTER ☰ 2 ☰
   HASH JOIN ☰ RIGHT ANTI ☰ 2 ☰
   HASH JOIN ☰ RIGHT OUTER ☰ 2 ☰
   HASH JOIN ☰ RIGHT SEMI ☰ 2 ☰
   HASH JOIN ☰ RIGHT SEMI BUFFERED ☰ 2 ☰
   HASH JOIN ☰ → development/databases/Oracle/SQL/join/semi[SEMI] ☰ 2 ☰ HASH JOIN SEMI seems to be the (left) counterpart to HASH JOIN RIGHT SEMI (so there is no HASH JOIN LEFT SEMI).
   HASH JOIN ☰  ☰ 2 - 3(?) ☰
   INDEX ☰ FAST FULL SCAN ☰ 1 ☰ Similar to → development/databases/Oracle/SQL/statement/execution/plan/operations/table-access/full[`TABLE ACCESS (FULL)`] but get requested values (attributes/columns) from an index rather than the table. Thus, the index is not used to locate rows. Compare with `INDEX FULL SCAN`.
   INDEX ☰ FULL SCAN ☰ 1 ☰
   INDEX ☰ FULL SCAN (MIN/MAX) ☰ 1 ☰
   INDEX ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/index_/range-scan[RANGE SCAN] ☰ 1 - 2 ☰
   INDEX ☰ RANGE SCAN (MIN/MAX) ☰ 1 ☰
   INDEX ☰ RANGE SCAN DESCENDING ☰ 1 ☰
   INDEX ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/index_/skip-scan[SKIP SCAN] ☰ 1 ☰
   INDEX ☰ UNIQUE SCAN ☰ 1 ☰
   INLIST ITERATOR ☰  ☰ 1 ☰ Iterate over each element in a `where x in (elem_1, elem_2, …, elem_n)` predicate and execute the child plan operation
   INSERT STATEMENT ☰  ☰ 1 ☰
   JOIN FILTER ☰ CREATE ☰ 1 ☰
   JOIN FILTER ☰ USE ☰ 1 ☰
   JSONTABLE EVALUATION ☰ ☰ ? ☰ Apparently used to execute statements with → development/databases/Oracle/SQL/functions/json/table[`json_table()`] expression.
   → development/databases/Oracle/SQL/statement/execution/plan/operations/load/as-select[LOAD AS SELECT] ☰  ☰ 1 ☰
   LOAD AS SELECT ☰ (CURSOR DURATION MEMORY) ☰ 1 - ? ☰ Related to the *star transformation* → development/databases/Oracle/optimizer#ora-optimizer-qry-tran[query transformation]
   LOAD AS SELECT ☰ (HYBRID TSM/HWMB) ☰ 1 ☰ TSM = Temp Segment Merge, HWMB = High Water Mark Brokering
   → development/databases/Oracle/SQL/statement/execution/plan/operations/load/table-conventional[LOAD TABLE CONVENTIONAL] ☰  ☰ 1 - n ☰
   MERGE ☰  ☰ 1 ☰
   MERGE JOIN ☰ ANTI ☰ 2 ☰
   MERGE JOIN ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/merge-join/cartesian[CARTESIAN] ☰ 2 ☰
   MERGE JOIN ☰ OUTER ☰ 2 ☰
   MERGE JOIN ☰ → development/databases/Oracle/SQL/join/semi[SEMI] ☰ 2 ☰
   MERGE JOIN ☰  ☰ 2 ☰
   MERGE STATEMENT ☰  ☰ 1 ☰
   MINUS ☰  ☰ 2 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/nested-loops[NESTED LOOPS] ☰ ANTI ☰ 2 ☰
   NESTED LOOPS ☰ ANTI SNA ☰ 2 ☰
   NESTED LOOPS ☰ OUTER ☰ 2 ☰
   NESTED LOOPS ☰ → development/databases/Oracle/SQL/join/semi[SEMI] ☰ 2 ☰
   NESTED LOOPS ☰  ☰ 1 - 3(?) ☰
   → development/databases/Oracle/optimizer/statistics/gathering/online/optimizer-statistics-gathering[OPTIMIZER STATISTICS GATHERING] ☰  ☰ 1 ☰ See → development/databases/Oracle/optimizer/statistics/gathering/online[Online statistics gathering]. Compare with `STATISTICS COLLECTOR`
   PARTITION LIST ☰ ALL ☰ 1 ☰
   PARTITION LIST ☰ ITERATOR ☰ ? ☰
   PARTITION LIST ☰ SINGLE ☰ 1 ☰ Access *one* partition only, see → development/databases/Oracle/objects/tables/partitions/distribution-techniques/list#ora-list-part-single[this example].
   PARTITION RANGE ☰ ALL ☰ 1 ☰
   PARTITION RANGE ☰ OR ☰ 1 ☰
   PARTITION RANGE ☰ SINGLE ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/px/block[PX BLOCK] ☰ ITERATOR ☰ 1 ☰
   PX BLOCK ☰ ITERATOR ADAPTIVE ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/px/coordinator[PX COORDINATOR] ☰  ☰ 1 ☰
   PX COORDINATOR ☰ FORCED SERIAL ☰ ? ☰ Oracle started with a parallel execution, but then detected during optimization phase that the statement cannot be executed in parallel (for example because of involving a PL/SQL function that is not parallel enabled).
   PX PARTITION LIST ☰ ALL ☰ 1 ☰
   PX PARTITION RANGE ☰ ☰ ☰ 
   PX PARTITION RANGE ☰ ALL  ☰ 1 ☰
   PX PARTITION RANGE ☰ ITERATOR ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/px/receive[PX RECEIVE] ☰  ☰ 1 ☰
   PX SELECTOR ☰  ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/px/send[PX SEND] ☰ 1 SLAVE ☰ 1 ☰
   PX SEND ☰ BROADCAST ☰ 1 ☰
   PX SEND ☰ HASH ☰ 1 ☰
   PX SEND ☰ HASH (BLOCK ADDRESS) ☰ 1 ☰
   PX SEND ☰ HASH (RANDOM) ☰ 1 ☰
   PX SEND ☰ HYBRID (ROWID PKEY) ☰ 1 ☰
   PX SEND ☰ HYBRID HASH ☰ 1 ☰
   PX SEND ☰ HYBRID HASH (SKEW) ☰ 1 ☰
   PX SEND ☰ QC (ORDER) ☰ 1 ☰
   PX SEND ☰ QC (RANDOM) ☰ 1 ☰
   PX SEND ☰ RANDOM LOCAL ☰ 1 ☰
   PX SEND ☰ RANGE ☰ 1 ☰
   PX SEND ☰ ROUND-ROBIN ☰ 1 ☰
   RESULT CACHE ☰  ☰ 1 ☰
   SELECT STATEMENT ☰  ☰ 1 - n ☰
   SEQUENCE ☰  ☰ 1 ☰
   SORT ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/sort/aggregate[AGGREGATE] ☰ 1 - 2 ☰ Used when → development/databases/Oracle/SQL/select/aggregate[aggregate functions] are applied to an entire table/subquery without → development/databases/Oracle/SQL/select/group-by[`group by`]. Compare with → development/databases/Oracle/SQL/statement/execution/plan/operations/buffer/sort[`BUFFER (SORT)`].
   SORT ☰ AGGREGATE APPROX ☰ 1 ☰ `AGGREGATE APPROX` is used, for example, in → development/databases/Oracle/SQL/functions/approx/count/distinct[`approx_count_distinct`].
   SORT ☰ GROUP BY ☰ 1 ☰
   SORT ☰ GROUP BY NOSORT ☰ 1 ☰
   SORT ☰ JOIN ☰ 1 ☰ Sort this operation's input before passing it to a `MERGE JOIN` operation. 
   SORT ☰ ORDER BY ☰ 1 ☰
   SORT ☰ ORDER BY STOPKEY ☰ 1 ☰
   SORT ☰ UNIQUE ☰ 1 ☰
   SORT ☰ UNIQUE NOSORT ☰ 1 ☰
   SQL MODEL ☰ ORDERED ☰  ☰
   STATISTICS COLLECTOR ☰  ☰ 1 ☰ Used in conjunction with → development/databases/Oracle/optimizer/adaptive[adaptive query optimzation] when the → development/databases/Oracle/optimizer creates an → development/databases/Oracle/SQL/statement/execution/plan/adaptive[adaptive plan]. Compare with `OPTIMIZER STATISTICS GATHERING`
   → development/databases/Oracle/SQL/statement/execution/plan/operations/table-access[TABLE ACCESS] ☰ BY GLOBAL INDEX ROWID BATCHED ☰ 1 ☰ 
   TABLE ACCESS ☰ BY INDEX ROWID ☰ 1 - 2 ☰
   TABLE ACCESS ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/table-access/by-index#ora-table-access-by-index-rowid-batched[BY INDEX ROWID BATCHED] ☰ 1 - 2 ☰ *BATCHED* indicates that the step retrieves a few → development/databases/Oracle/SQL/data-types/rowid[rowids] from an → development/databases/Oracle/objects/indexes[index] and then tries to access the corresponding rows in order of the → development/databases/Oracle/architecture/database/logical-structures/data-block[blocks] so that the number of times that a block is read is minimized.
   TABLE ACCESS ☰ BY LOCAL INDEX ROWID BATCHED ☰ 1 ☰
   TABLE ACCESS ☰ BY USER ROWID ☰ 1 ☰
   TABLE ACCESS ☰ CLUSTER ☰ 1 ☰
   TABLE ACCESS ☰ → development/databases/Oracle/SQL/statement/execution/plan/operations/table-access/full[FULL] ☰ 1 ☰
   TABLE ACCESS ☰ HASH ☰ 1(?) ☰
   TABLE ACCESS ☰ SAMPLE ☰ 1 ☰
   TABLE ACCESS ☰ SAMPLE BY ROWID RANGE ☰ 1 ☰
   TEMP TABLE TRANSFORMATION ☰  ☰ 3 ☰
   UNION ALL PUSHED PREDICATE ☰  ☰ 2(?) - n ☰
   UNION-ALL ☰  ☰ 1 - n ☰
   UNPIVOT ☰  ☰ ☰
   UPDATE ☰  ☰ 1 - n ☰
   UPDATE STATEMENT ☰  ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/view[VIEW] ☰  ☰ 1 ☰ A passive operation: it passes its resultset to the parent operation. → https://www.red-gate.com/simple-talk/databases/oracle-databases/execution-plans-part-7-query-blocks-and-inline-views/[Jonathan Lewis] says the VIEW operator identifies a seperately optimized → development/databases/Oracle/SQL/statement/query-block (in a possibly transformed SQL statement) whose result set might be completely built in memory before passing it to the parent operators. Compare with the plan operation → development/databases/Oracle/SQL/statement/execution/plan/operations/filter[`FILTER`].
   VIEW PUSHED PREDICATE ☰  ☰ 1 ☰
   → development/databases/Oracle/SQL/statement/execution/plan/operations/window[WINDOW] ☰ BUFFER ☰ 1 ☰ Used in `over()` clauses in an → development/databases/Oracle/SQL/select/analytic[analytic function] when the clause does not contain a `partition by` or `order by`.
   WINDOW ☰ SORT ☰ 1 ☰ Used in `over()` clauses when the clause contains a `partition by` or `order by`.
   WINDOW ☰ SORT PUSHED RANK ☰ 1 ☰
   WINDOW (IN SQL MODEL) ☰ ORDERED ☰ ☰
   XMLTABLE EVALUATION ☰  ☰ 1 ☰ Related to the SQL function → development/databases/Oracle/SQL/functions/XML/Table[`XMLTable`]?

table }

This table was produced with raw data that was selected with the following → development/databases/Oracle/SQL/select[select] statement:
code {
with sp as (
   select
      p.operation  p_operation,
      p.options    p_options,
      c.operation  c_operation,
      c.options    c_options,
      p.id         p_id,
      p.sql_id,
      p.child_number,
      c.sql_id c_sql_id, c.child_number c_child_number, c.parent_id c_parent_id, 
      rank() over (partition by c.sql_id, c.child_number, c.parent_id order by c.position) r_child
   from
      v$sql_plan p                                           left join
      v$sql_plan c   on p.sql_id       = c.sql_id       and
                        p.child_number = c.child_number and
                        p.id           = c.parent_id
   /*                     
   where
     not (
        ( p.operation = 'FILTER'                     and p.options is null) or
        ( p.operation = 'UNION-ALL'                  and p.options is null) or
        ( p.operation = 'UNION ALL PUSHED PREDICATE' and p.options is null) or
        ( p.operation = 'SELECT STATEMENT'           and p.options is null) or
        ( p.operation = 'LOAD AS SELECT'             and p.options = '(CURSOR DURATION MEMORY)') or
        ( p.operation = 'LOAD TABLE CONVENTIONAL'    and p.options is null) or
        ( p.operation = 'CREATE TABLE STATEMENT'     and p.options is null)
     )
   */
),
gr as (
   select
      p_operation,
      p_options,
   -- p_id,
   -- sql_id,
      child_number,
      max(r_child) max_r_child
   from
      sp
   group by
      p_operation,
      p_options,
      p_id,
      sql_id,
      child_number
)
select
   count(*) over (partition by p_operation, p_options) cnt,
   p_operation,
   p_options,
   max_r_child
from
   gr
group by
   p_operation,
   p_options,
   max_r_child
order by
   p_operation,
   p_options;
code }

{ TODO

  Find parent child operation relations:
code {
select
   count(*) cnt,
   p .operation, p .options,
   c1.operation, c1.options,
   c2.operation, c2.options,
   c3.operation, c3.options
from
   v$sql_plan    p                                                                                                           left join
   v$sql_plan    c1 on p.sql_id = c1.sql_id and p.child_number = c1.child_number and p.id = c1.parent_id and c1.position = 1 left join
   v$sql_plan    c2 on p.sql_id = c2.sql_id and p.child_number = c2.child_number and p.id = c2.parent_id and c2.position = 2 left join
   v$sql_plan    c3 on p.sql_id = c3.sql_id and p.child_number = c3.child_number and p.id = c3.parent_id and c3.position = 3
where
   p.operation = 'PX BLOCK'
group by
   p .operation, p .options,
   c1.operation, c1.options,
   c2.operation, c2.options,
   c3.operation, c3.options
order by
   p .operation, p .options,
   c1.operation, c1.options,
   c2.operation, c2.options,
   c3.operation, c3.options
;
code }

  Find plans with a given operation
code {
with s as (
   select distinct
      sql_id,
      child_number
   from
      v$sql_plan
   where
      operation = 'VIEW'
)
select
    lpad(' ', 2*p.depth) || p.operation || ' ' || p.options,
    p.object_name,
    p.object_alias,
    p.object_type,
    t.sql_text,
    count(*) over (partition by s.sql_id, s.child_number) cnt
from
    s                                                 join
    v$sql_plan p on s.sql_id       = p.sql_id and
                    s.child_number = p.child_number  join
    v$sqlarea  t on t.sql_id       = p.sql_id
order by
    cnt,
    s.sql_id,
    s.child_number,
    p.id;
    
code }

}

sa:

  → development/databases/Oracle/installed/dynamic-performance-views/sql/plan/statistics[`v$sql_plan_statistics`] provides *actual* (not estimated as in → development/databases/Oracle/installed/dynamic-performance-views/sql/plan[`v$sql_plan`])
  statistics for every plan operation of an → development/databases/Oracle/SQL/statement/execution[executed SQL statement].
  -
  → development/databases/Oracle/installed/dynamic-performance-views/sql/plan/monitor[`v$sql_plan_monitor`] reports those actual data even broken down to a single
  → development/databases/Oracle/SQL/statement/execution[execution of an SQL statement].

  → development/databases/Oracle/SQL/statement/execution/plan[SQL statement execution plan]
