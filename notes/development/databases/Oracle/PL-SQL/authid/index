$ Oracle PL/SQL: AUTHID CURRENT_USER | DEFINER
@ authid

A → development/databases/Oracle/PL-SQL stored procedure runs either with in the context and the privileges of the caller (`authid current_user`) or
in the context and with the privilges of the procedure's owner (`authid definer`).

The optional `authid` clause specifies which behavior the stored procedure assumes. It can be set to
  • `authid current_user` (procedure runs in context of caller)
  • `authid definer` (procedure runs n context of owner)

When not specified, the default is `authid definer`.

The `authid` clause
immediatly follows the `create procedure`, `create function`, `create package` or
`create type` statements, as shown in the following:
 -
  `authid` as used in a package declaration …
code {
create package pkg
   AUTHID CURRENT_USER
as
   … 
end pkg;
/
code }

  … in a function and procedure definition …
code {
create function f return number
   AUTHID CURRENT_USER
as begin
   …
end f;
/

create procedure p
  AUTHID CURRENT_USER
as begin
  null;
end p_authid_cu;
/
code }

  … and a type definition:
code {
create type t
   AUTHID CURRENT_USER
as object (
   …
);
code }

{ Effects on roles

  A procedure with `authid definer` disables all → http://www.adp-gmbh.ch/ora/misc/users_roles_privs.html#roles[roles] that are granted to the caller. This can lead to
  → http://www.adp-gmbh.ch/ora/err/ora_00942.html[ORA-00942] errors.

  If the procedure is created with `authid current_user`, the roles of the caller are enabled when the procedure is executed. However, in order to compile the procedures, the privileges still need to be granted directly.
}

{ Examples

  { Example from adp-gmbh.ch

    This is an example that I copied from my old web site → http://www.adp-gmbh.ch[adp-gmbh.ch].

    First, two users are created, one named `A` and the other named `B`. They're given the required → development/databases/Oracle/security/privileges[privileges] for this example:
code {
create user a identified by a default tablespace data quota unlimited on data;
create user b identified by b default tablespace data quota unlimited on data;

grant create session, create procedure, create table to a;
grant create session, create procedure, create table to b;
code }

    Now, user `A` creates two tables, named `T` and `U` and fills them with `'this is a''s table'`.

    User `U` is then allowed to read `T` (but not `U`).
code {
connect a/a;

create table t (d varchar2(40));
insert into  t values ('this is a''s table');

commit;

create table u (d varchar2(40));
insert into  u values ('this is a''s table');

grant select on t to b;
-- no grant on u
code }

    User `A` also creates a procedure (named `PT`) with `authid current_user` that just reads what was filled into table `T`:
code {
create procedure pt
 authid current_user
as
  v_d t.d%type;
begin
  select d into v_d from t; 
  dbms_output.put_line(v_d);
end;
/
code }

    User `A` then creates another procedure, `PU`, that reads from table `U`. This procedure has `authid definer`:
code {
create procedure pu
 authid definer
as
  v_d t.d%type;
begin
  select d into v_d from u; 
  dbms_output.put_line(v_d);
end;
/
code }

    User `B` is granted the right to execute both procedures:
code {
grant execute on pt to b;
grant execute on pu to b;
code }

    Now, user `B` comes into play. This user also creates two tables, again named `T` and `U` and fills them with `'this is b''s table'`:
code {
connect b/b;

create table t (d varchar2(40));
insert into  t values ('this is b''s table');

create table u (d varchar2(40));
insert into  u values ('this is b''s table');

commit;
code }

    Now, `B` executes procedure `PT`:
code {
set serveroutput on
begin a.pt; end;
/
code }
   
    The output is:
code {
this is b's table
code }

    Then, `B` executes `PU`
code {
begin a.pu; end;
/
code }

   This time, the output is:
code {
this is a's table
code }

    This demonstrates that a procedure is run in the context of the caller if has `authid current_user` and in the context of the owner if the procedure has `authid definer`.

  }
  { EXECUTE IMMEDIATE #authod-exec-immediate

    The following example tries to demonstrate that → development/databases/Oracle/PL-SQL/execute-immediate[`execute immediate`] is executed in the context of the user that invokes a procedure
    that is defined with `authid current_user`:

    gh|Oracle-Patterns|/PL-SQL/authid/create_object.sql||

  }
  { Another example

    Another example that I should describe, eventually…

    gh|Oracle-Patterns|/PL-SQL/authid/example_01.sql||

  }

}
