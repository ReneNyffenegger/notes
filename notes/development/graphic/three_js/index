$ three.js

A three.js application needs at least a *scene*, a *camera* and a *renderer*.

{ Using (importing) three.js

  As of version r147, the preferred way to use three.js is via es6 modules and *import maps*
code {
<script type='importmap'>
  {
    "imports": {
      "three"        : "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
</script>

<script type='module' src='app.js'></script>
code }

  `app.js`:
code {
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
code }


}
{ Scene

  A `Scene` inherits from `Object3D` and extends it with some properties of which the most interesting ones are:
    • `.background` (which is a color, a texture, or a `CubeTexture` or equirectangular texture for a skybox.
    • `.fog`

? A scence is (typically?) rendered by a renderer (WebGLRenderer or WebGPURenderer (or CanvasRenderer? or others?))

  The objects of a scene are arranged hierarchically in a → https://threejs.org/manual/#en/scenegraph[scene graph].

}
{ Camera

  Abstract base class for cameras.

  The most frequently used derived classes are `PerspectiveCamera` and `OrthographicCamera`.

  Although I have seen examples where a camera is explicitely added to a scene, it is apparently → https://github.com/mrdoob/three.js/issues/1046[not necessary] to do so.
 (because the influence of the camara is being taken care of with in the line `renderer.render(scene, camera)`.
  -
  It's worth noting that a camera can be added to an object such as a car driving through a scene.

  { Constructing a perspective camera

    A «full screen» camera is typically created like so:    
code {
const camera = new THREE.PerspectiveCamera(
   45,                                     // field of view (fov)
   window.innerWidth / window.innerHeight, // aspect
   0.1, 10000                              // near, far
);
code }

  }
  { lookAt

code {
camera.lookAt(new THREE.Vector3(x, y, z));
code }

  }
  { cameraHelper

    An instance of a `cameraHelper` uses line segments to visualize the frustum of a camera.

code {
const camHlp = new THREE.CameraHelper(camera);
scene.add(camHlp);
code }


   In the render loop:
code {
camHlp.update();
code }

  }

}
{ WebGLRenderer

  An instance of a `WebGLRenderer` renders a scene using a camera.

  See also the `WebGPURenderer` class.

  { domElement

    The renderer's `domElement` is a `HTMLCanvasElement` (i. e. a `<canvas>`) on which the renderer draws («renders») the scence.
    -
    Hence, this `domElement` must be added to the HTML document:
code {
const container = … // for example: document.createElement('div');
document.body.appendChild(container);
container.appendChild(renderer.domElement);
code }

  }
  { Animation loop

code {
clock    = new THREE.Clock();
renderer = new THREE.WebGLRenderer();
scene    = …
camera   = …
…
renderer.setAnimationLoop(animate);

function animate() {
   const delta = clock.getDelta();
   const time  = clock.getElapsedTime();

   xyz.rotation.x = time * 0.333;
   xyz.rotation.y = time * 0.500;

   t += delta * 0.5;
   … = Math.sin(t);

   renderer.render(scene, camera);

   stats.update();
}
code }

  }

}
{ Geometry

  A *geometry* stores the *vertex data* of an object.

  With r125, → https://discourse.threejs.org/t/three-geometry-will-be-removed-from-core-with-r125/22401[`THREE.Geometry` was removed] and
 `THREE.BufferGeometry` was suggested as replacement.

  { THREE.BufferGeometry

    All geometries seem to inherit from `BufferGeometry`.
    -
   `BufferGeometry` inherits from `EventDispatcher` (not from `Object3D`, but has the member property → https://github.com/mrdoob/three.js/blob/beab9e845f9e5ae11d648f55b24a0e910b56a85a/src/core/BufferGeometry.js#L16[`_obj`] which *is* an `Object3D`).

    An instance of a → https://threejs.org/docs/index.html?q=buffergeometry#api/en/core/BufferGeometry[`THREE.BufferGeometry`] represents a
      • mesh,
      • line or
      • point geometry

    Besides geometrical data like vertex coordinates, an instance also stores attributes such as
      • face indices
      • (vertex?) normals
      • colors
      • UVs
      • custom attributes (which are used to reduce the cost of passing this data to the GPU)

   `BufferAttribute` is a class that is designed to store a BufferGeometry's attributes in an efficient way to pass it to a GPU.

    Classes that inherit from `BufferGeometry` include
      • `BoxGeometry`
      • `CircleGeometry`
      • `CylinderGeometry` (from which `ConeGeometry` inherits)
      • `EdgesGeometry`
      • `ExtrudeGeometryk`
      • `LatheGeometry` (from which `CapsuleGeometry` inherits)
      • `PlaneGeometry`
      • `PolyhedronGeometry`
      • `RingGeometry`
      • `ShapeGeometry`
      • `SphereGeometry`
      • `TorusGeometry`
      • `TorusKnotGeometry`
      • `TubeGeometry`
      • `WireframeGeometry` (the construtor of which takes another geometry as parameter)

    Classes that inherit from `PolyhedronGeometry` include
      • `DodecahedronGeometry`
      • `IcosahedronGeometry`
      • `OctahedronGeometry`
      • `TetrahedronGeometry`

  }
  { TextGeometry

?   A `TextGeometry` (found in → https://github.com/mrdoob/three.js/tree/beab9e845f9e5ae11d648f55b24a0e910b56a85a/examples/jsm/geometries[`/examples/jsm/geometries`]) creates a `ExtrudeGeometry` from a 3D font (which must first be loaded) and a string.

    The 3D font can be loaded with an instance of a `FontLoader`.

  }
  { Vertex normals

    ? Vertex normals
      • determine light reflection
      • assist in applying textures
      • provide information how pixels are lighted, shaded and colored

    `VertexNormalsHelpers` (which inherits from `LineSegments`) visualizes an object's vertex normals.

     See also the `BufferGeometry` method `computeVertexNormal()`.

  }
}
{ Material

  A material describes an object's surface properties (so it directly influences how the looks like).

  Some materials include
    • `MeshLambertMaterial` (Rough-looking surfaces)
    • `MeshPhongMaterial` (Shiny-looking surfaces, *is* affected by lights)
    • `MeshBasicMaterial` (*not* affected by lights)
    • `LineBasicMaterial` (for *wireframe-style* geometries)
    • `MeshToonMaterial` (Cartoon like objects)
    • `ShadowMaterial` (A transparent material that shows shadows cast on it)
    • `MeshStandardMaterial`

  { LineBasicMaterial

   `LineBasicMaterial` has the property `linewidth` but, → https://threejs.org/docs/index.html#api/en/materials/LineBasicMaterial.linewidth[due to limitations] of the → https://registry.khronos.org/OpenGL/specs/gl/glspec46.core.pdf[OpenGL Core Profile] with the
    WebGL renderer, on most platforms this value will be `1` regardless of the set value. 

  }
  { Shader program

    A material seems to be connected with a *shader program* (see the material's callback `onBeforeCompile`)

  }

}
{ Mesh

  A mesh is an object that applies a *material* to a *geometry*.

  A material and/or a geometry can be used for mulitple meshes.

  A mesh inherits from `Object3D` and thus records the following attributes of an object relative to its parent in the scene:
    • position
    • orientation
    • scale

  The mesh can then be inserted into a *scene* (for example `scene.add()`) and then be moved around

  TODO: → https://discourse.threejs.org/t/three-js-instancing-how-does-it-work/32664/2[`InstancedMesh`]. Is this related to `InstancedBufferGeometry`àk/

}
{ Light

 `Light` is the abstract base class for an object that emits light.

  Some interesting derived classes include:
    • `AmbientLight` which illuminates all objects equally and doesn't cast shadows
    • `DirectionalLight`, a source that is infinitely far away, typically used to simulate the Sun.
    • `PointLight` which emits light equally in all directions (a «light bulb»)
    • `SpotLight`

}
{ Texture

  Classes that inherit from `Texture` include:
    • `CanvasTexture` (Crated from a `<canvas>` element)
    • `CompressedTexture`
    • `CompressedArrayTexture`
    • `CubeTexture` (Made up of six textures, each for a side of a cube)
    • `Data3DTexture`
    • `DataArrayTexture`
    • `DataTexture`
    • `DepthTexture`
    • `FramebufferTexture (can only be used with `WebGLRenderer.copyFramebufferToTexture()`).
    • `VideoTexture`  

  See also the `Source` class
 

  { Creation of textures

    A texture can be created from
      • static images
      • HTML 5 canvas elements
      • … ?

  }
  { Creating a texture from a HTML 5 canvas element:

code {
const canvas = document.createElement('canvas'),
ctx = canvas.getContext('2d')
canvas.width  = …
canvas.height = …
  …
const texture  = new THREE.Texture(canvas)
const material = new THREE.MeshStandardMaterial({ map: texture })
const geometry = new THREE.BoxGeometry(200, 200, 200)
const mesh     = new THREE.Mesh(geometry, material)
scene.add(mesh)
  …
ctx.fillStyle = '#435acd'
ctx.fillRect(0, 0, canvas.width, canvas.height)
ctx.font = '15pt Arial'
…
code }

  }
  { Texel

? The pixels of a texture are referred to as texels.

  }

}
{ Material

  The material specifies an object's appearance.

}
{ Color

code {
scene = new THREE.Scene();
scene.background = new THREE.Color(0x2f0b03);
code }

}
{ Fog

code {
scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 250, 1400);
code }

}
{ Vector…

code {
cameraTarget = new THREE.Vector3( 0, 150, 0 );
code }

}
{ Object3D

 → https://threejs.org/docs/#api/en/core/Object3D[`Object3D`] is the base class for most objects in three.js.

  Every instance of an `Object3D` object has an associated *matrix* (→ #matrix4) which defines the object's transformations: position, rotation and scale.

  An object's matrix-transformation is relativ to the object's parent object. The transformation relative to the world can be obtained with `obj.matrixWorld`.

  A → https://threejs.org/docs/#api/en/objects/Bone[`Bone`] is almost identical to a blank `Object3D`.

  The `Group` class is almost identical to `Object3D`.

}
{ Group

  The purpose of `Group` is to make working with groups of objects syntactically easier.

 `Group` is almost identical to the `Object3D` class.

}
{ Controls

  Abstract base class for control objects.

  Control objects control an `Object3D`, usually a camera.

}
{ Fullscreen: window.resize event 

code {
window.addEventListener('resize', onWindowResize);

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
}
code }

}
{ Raycaster

? The `Raycaster` class allows to select objects (meshes, lines and/or point etc.) with the mouse.

}
{ Matrix4 #matrix4

}
{ TODO

  { Line like objects

    → https://threejs.org/docs/index.html#api/en/objects/Line[`Line`] which inherits from `Object3D`, → https://threejs.org/docs/index.html#api/en/objects/LineSegments[`LineSegments`] which inherits from `Line`,
    → https://threejs.org/docs/index.html#examples/en/lines/LineSegments2[`LineSegments2`] which inherits from `Mesh`,
    → https://threejs.org/docs/index.html#examples/en/lines/Line2[`Line2`] which inherits from `LineSegments2`,
    → https://threejs.org/docs/#examples/en/lines/LineSegmentsGeometry[`LineSegmentsGeometry`] which inherits from → https://threejs.org/docs/index.html#api/en/core/InstancedBufferGeometry[`InstancedBufferGeometry`]

    → https://threejs.org/docs/#api/en/objects/LineLoop[`LineLoop`] inherits from `Line` but is rendered with `gl.LINE_LOOP` instead of `gl.LINE_STRIP`.

  }

}

sa:

  → development/web/libraries/D3_js
