$ make

{ Recursively turn each cpp file into an executable

code {
SOURCES=$(shell find -type f -iname '*.cpp')

all: $(SOURCES:.cpp=)
code }

See → https://stackoverflow.com/a/9996597/180275[this stackoverflow answer].

}
{ Multiple processors #multiple_processors

  With multiple processors (or cores), the compilation time can be reduced by parallelizing the tasks.

  This can be achieved with `export MAKEFLAGS='-j 2'` or just `make -j2`.

  The number of available processing units can be determined with → Linux/shell/commands/nproc (`MAKEFLAGS="-j $(nproc)"`).

}
{ Standard targets

  `all`: Default target (same as just invoking `make`). Builds the executables, libraries, documentation etc.

  `install`: install built things.
   -
  `install-strip`: like `install`, but additionally strip debugging symbols.
   -
   By default, `make install` will install the files in → Linux/fhs/usr/local/bin, → Linux/fhs/usr/local/lib etc. (That is: under → development/GNU/toolchain/Build-System/prefix, which can be overwritten with
   `→ development/GNU/toolchain/Build-System/configure[`./configure --prefix=...`).
   

  `clean`: opposite of `make install`
  -
  `distclean`: Also get rid of any files that → development/GNU/toolchain/Build-System/configure[`./configure`] has created.

  `check`: run tests (if available)
   -
  `installcheck`: check the installed libraries.

  `dist`: create `PACKAGE-VERSION.tar.gz`
  -
  `distcheck`: like `dist` with additional sanity checks. Prefer `distcheck` over `dist`.

  `maintainer-clean`

}
{ Show make's default rules

  The `-p` option prints the rules and variable values (referred to as *database*) that take effect with the given Makefile.

   The `-f` option specifies the makefile (default is: `Makefile`), thus `-f → Linux/fhs/dev/null` makes sure that no Makefile is read.
code {
make -p
make -p -f→ Linux/fhs/dev/null
code }

`make` calls these default rules the »internal database«.

}
{ Misc Makefile examples


  gh|about-Makefile|/@||

  gh|about-Makefile|/shell||

  gh|about-Makefile|/dir||

  gh|about-Makefile|/info||

  gh|about-Makefile|/ifeq||

  gh|about-Makefile|/origin||

  gh|about-Makefile|/ifdef||

  { Turning each c files into an executable

    If a directory contains three c files: `foo.c`, `bar.c` and `baz.c`, then they can be compiled into the three executables `foo`, `bar` and `baz` with
    the following simple make file:

    gh|about-Makefile|/compile-each-c-file/Makefile||

  }

}
{ Functions

   → development/make/functions/call[`$(call …)`]

   → development/make/functions/foreach[`$(foreach …)`]

   → development/make/functions/subst[`$(subst …)`]

}
{ TODO

  → development/make/variables[Variables] in make.

   MinGW seems to name the make executable `mingw32-make.exe`.
   -
   Strawberry → development/languages/Perl[Perl] seems to name it `gmake.exe`. It also comes with a `dmake.exe`...

   → https://metacpan.org/pod/distribution/Makefile-GraphViz/script/gvmake[gvmake]


}
sa:
  → development/make/detect-os

  → development/GNU/toolchain/Build-System/Autoconf/macros/AC_SUBST

  → development/GNU-Build-System/automake.

  → development/tools/scripts/personal/make-targets: A → development/tools/scripts/personal[script] that shows the targets of a makefile.



links:

  The → https://gmsl.sourceforge.io/[GNU Make Standard Library] s a collection
  of functions implemented using native GNU Make functionality that provide
  list and string manipulation, integer arithmetic, associative arrays, stacks,
  and debugging facilities.

  → https://github.com/mbcrawfo/GenericMakefile
