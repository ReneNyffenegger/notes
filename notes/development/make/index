$ make

{ Recursively turn each cpp file into an executable

code {
SOURCES=$(shell find -type f -iname '*.cpp')

all: $(SOURCES:.cpp=)
code }

See → https://stackoverflow.com/a/9996597/180275[this stackoverflow answer].

}
{ Multiple processors #multiple_processors

  With multiple processors (or cores), the compilation time can be reduced by parallelizing the tasks.

  This can be achieved with `export MAKEFLAGS='-j 2'` or just `make -j2`.

  The number of available processing units can be determined with → Linux/shell/commands/nproc (`MAKEFLAGS="-j $(nproc)"`).

}
{ Standard targets

  `all`: Default target (same as just invoking `make`). Builds the executables, libraries, documentation etc.

  `install`: install built things.
   -
  `install-strip`: like `install`, but additionally strip debugging symbols.
   -
   By default, `make install` will install the files in → Linux/fhs/usr/local/bin, → Linux/fhs/usr/local/lib etc. (That is: under → development/GNU/toolchain/Build-System/prefix, which can be overwritten with
   `→ development/GNU/toolchain/Build-System/configure[`./configure --prefix=...`).
   

  `clean`: opposite of `make install`
  -
  `distclean`: Also get rid of any files that → development/GNU/toolchain/Build-System/configure[`./configure`] has created.

  `check`: run tests (if available)
   -
  `installcheck`: check the installed libraries.

  `dist`: create `PACKAGE-VERSION.tar.gz`
  -
  `distcheck`: like `dist` with additional sanity checks. Prefer `distcheck` over `dist`.

  `maintainer-clean`

}
{ Show make's default rules

  The `-p` option prints the rules and variable values (referred to as *database*) that take effect with the given Makefile.

code {
make -p
make -p -f→ Linux/fhs/dev/null
code }

`make` calls these default rules the »internal database«.

}
{ Misc Makefile examples

  gh|about-Makefile|/wildcard||

  gh|about-Makefile|/@||

  gh|about-Makefile|/shell||

  gh|about-Makefile|/dir||

  gh|about-Makefile|/info||

  gh|about-Makefile|/ifeq||

  gh|about-Makefile|/origin||

  gh|about-Makefile|/ifdef||

  { Turning each c files into an executable

    If a directory contains three c files: `foo.c`, `bar.c` and `baz.c`, then they can be compiled into the three executables `foo`, `bar` and `baz` with
    the following simple make file:

    gh|about-Makefile|/compile-each-c-file/Makefile||

    See also → https://github.com/ReneNyffenegger/about-Makefile/tree/master/compile-each-c-file

  }
  { Variables 

    gh|about-Makefile|/variables/append||


    ~Automatic variables~: 

    gh|about-Makefile|/variables/automatic/lt||

    gh|about-Makefile|/variables/automatic/at||

  }

}
{ TODO

   MinGW seems to name the make executable `mingw32-make.exe`.
   -
   Strawberry → development/languages/Perl[Perl] seems to name it `gmake.exe`. It also comes with a `dmake.exe`...

   → https://metacpan.org/pod/distribution/Makefile-GraphViz/script/gvmake[gvmake]

}
sa:
  → development/GNU/toolchain/Build-System/Autoconf/macros/AC_SUBST

  → development/GNU-Build-System/automake.

  → development/tools/scripts/personal/make-targets: A → development/tools/scripts/personal[script] that shows the targets of a makefile.


links:
  → https://github.com/mbcrawfo/GenericMakefile
