
Wikidata does not primarily aim to store facts about the world, rather it tries to collect links to refences to knowledge.
-
Therefore, it's possible to have conflicting information in Wikidata which gives raise to the *statement ranks* (preferred, normal and deprecated).

→ https://www.wikidata.org/wiki/Special:Search[Search] for Q numbers. Use the `p:` prefix to search for identifiers for an item.

{ Data model

  The «Q Nr» of the *wikidata data model* is → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354757[Q16354757].

  With SPARQL, its possible to query some features of that data model.

  { Wikidata data model parts

    The following query selects the (three) wikidata data model parts (using the P527 relation):
      • Wikidata claim (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354754[Q16354754])
      • Wikidata property (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q18616576[Q18616576])
      • Wikidata statement rank (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q21044622[Q21044622])

code {
select

     ?wikidataPart_
#  ( substr(str(?part_), 32) as ?qNr )
     ?wikidataPart
{  #
   # Q16354757: Wikidata Data Model
   # P527:      has parts
   #

     → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354757[wd:Q16354757]      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P527[wdt:P527]      ?wikidataPart_ .
    ?wikidataPart_    rdfs:label     ?wikidataPart  . filter(lang(?wikidataPart) = 'en')

}
order by
   lcase(?wikidataPart)
code }

  }
  { Parts of the wikidata data model:

    Similarly, the → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P361[P361] relation shows the parts of the wikidata data model:
      • concept of unknown value in Wikibase (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q19798648[Q19798648])
      • Wikidata value (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107658963[Q107658963])
      • Wikidata label (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107659597[Q107659597])
      • Wikidata alias (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107659723[Q107659723])
      • Wikidata description (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107659784[Q107659784])
      • Wikidata term (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q108060110[Q108060110])
      • interwiki link (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q677652[Q677652])
      • Wikidata item (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16222597[Q16222597])
      • Wikidata claim (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354754[Q16354754])
      • Wikidata property (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q18616576[Q18616576])
      • Wikibase data model element (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q19798644[Q19798644])
      • concept of no-value in Wikibase (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q19798647[Q19798647])

code {
select

     ?part_
#  ( substr(str(?part_), 32) as ?qNr )
     ?part
{  #
   # Q16354757: Wikidata Data Model
   # P361:      part of
   #

    ?part_     wdt:P361   wd:Q16354757 .
#   wd:Q16354757     wdt:P361   ?part  .
    ?part_    rdfs:label ?part         . filter(lang(?part) = 'en')

}
order by
   lcase(?wikidataPart)
code }

    I am not sure why some parts are modelled with the P527 and others with the P361 relation.

  }
  { Entities

    Wikidata has *subjects* on which → development/Data/structured is stored. These subjects are called ~entities~.

    There are two types of entities:
      • item (whose identifier starts with `Q`)
      • property (whose identifiers start with `P`)

    The entities and properties form a *directed graph* in which the entities are the nodes and the properties are the edges.

    The model is different from → development/web/RDF[RDF] in that the graphs's edges (i.e. the properties) can be annotated. Such annotations
    record the source of the information, the temporal validity etc.

    The Q Number for *Wikidata entity* is → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/32753077[Q32753077].

    An S. N. A. K. (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q86719099[Q86719099]) is the *basic information structure used to describe entities in Wikidata*.

  }
  { Item

    An item has typically a Wikipage in at least one Wikipedia language.

    An *item page* consists of (at least?) these main parts
      • *label*
      • *description*
      • list of *aliases*
      • list of *statements*
      • list of *site links*

    An item is identified by
      • its Q-number, or
      • the combination of label and description.

    Label, description and aliases are also known by *terms*. These are used to find and display items.

  }
  { Property

    Properties have *terms* but no statements or site links.

    A property has a *data type* that constrains the accepted range of values.

    Interesting properties include
    table { ll
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P17[P17] ☰ The sovereign state in which subject is located, not to be used for human beings. Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P131[P131].
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P18[P18] ☰ image
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P31[P31] ☰ *instance of*, corresponds to `rdf:type`. Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P279[P279 (subclass of)], → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P463[P463] (member of) and → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P1963[P1963] (has property).
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P131[P131] ☰ located in the administrative territorial entity (Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P17[P17], → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P276[P276], → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P1382[P1382])
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P276[P276] ☰ Location. (Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P131[P131], P625, P8138, P706, P7153)
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P279[P279] ☰ *instance of*. Corresponds to `rdfs:subClassOf`. Compare with P31.
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P402[P402] ☰ → development/OpenStreetMap[OpenStreetMap] relation ID. Compare → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P3896[P3896]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P571[P571] ☰ start date, compare → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P576[P576]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P576[P576] ☰ dissolved, abolished or demolished date, Compare → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P582[P582], → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P571[P571]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P585[P585] ☰ Point in time
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P625[P625] ☰ WGS84-Coordinates of subject. Distances between two such coordinates can be calculated with `geof:distance(?c1, ?c2)`. Compare with `P2044` (elevation).
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P771[P771] ☰ Swiss municipality code (BFS Number)
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P856[P856] ☰ Official website, compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P6269[P6269]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P1566[P1566] ☰ Geonames ID (formatter is → https://www.geonames.org/8740955[`https://www.geonames.org/$1`])
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P3896[P3896] ☰ Geoshape (Wikicommons). Compare → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P402[P402]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P5305[P5305] ☰ → development/databases/query-languages/SPARQL Endpoint
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P6269[P6269] ☰ Base → development/web/URI-URL-URN-IRI-URC[URL] of a → development/web/service. Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P856[P856]
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P8402[P8402] ☰ → development/Data/open[Open Data] portal
    table }

    { TODO


      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107649491[Q107649491] is a wikidata metaclass for *property-types*.

      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P1629[P1629] links a property to a wikidata item that corresponds to the concept that is represented by that property.

    }

  }
  { Q...

    table { ll
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q5[Q5] ☰ human. Compare with → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q15978631[Q15978631].
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q83[Q83] ☰ MediaWiki
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q341[Q341] ☰ Free software
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q7397[Q7397] ☰ Computer Software
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q42848[Q42848] ☰ → development/Data.
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q70208[Q70208] ☰ Swiss municipality
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q7907943[Q7907943] ☰ Vaccine Adverse Event Reporting System (VAERS)
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354757[Q16354757] ☰ Wikidata Data Model (see this → https://commons.wikimedia.org/wiki/File:Datamodel_in_Wikidata.svg[SVG graphic])
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q16354758[Q16354758] ☰ Wikibase (collection of software for structured data)
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q19798645[Q19798645] ☰ Wikibase datatype
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q107649491[Q107649491] ☰ Type of wikidata properties
      → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q108606989[Q108606989] ☰ → development/Data/open/Wikimedia article badge
    table }

  }
  { L…

    Lexemes start with an L, for example → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/L43313[L43313].

  }
  { E… (Schema)

    There is also a concept of → https://www.wikidata.org/wiki/Wikidata:WikiProject_Schemas[schemas]. Their identifier starts with E, for
    example → https://www.wikidata.org/wiki/EntitySchema:E13[E13: natural numbers],
    → https://www.wikidata.org/wiki/EntitySchema:E16[E16: software titles] or
    → https://www.wikidata.org/wiki/EntitySchema:E100[E100: cities]

    A Schema is used to define a set of rules to which the subset of wikidata that belongs to this schema should conform.

  }
  { Statements #wikidata-statements

    A statement can be enriched with a *qualifier* which provides additional context information for the claim.
    -
    Qualifiers are expressed as properties.
    -
    Examples for qualifiers are *start date* (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P580[P580]) or *end date* (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P582[P582]).

    A statement can include one or more *references* which support the claim.
    -
    A reference is property-value pair (or a list of property-value pairs?)

    { Rank

      A statement has an associated → https://www.wikidata.org/wiki/Help:Ranking[rank] which is one of
      table { lll
        preferred ☰ `wikibase:PreferredRank` ☰ Typically used for the most up-to-date value or the value with the broadest consensus, and is ideally applied to a → https://www.wikidata.org/wiki/Help:Sources[sourced statement] (See P248 «stated in» and P854 «reference URL»)
        normal ☰ `wikibase:NormalRank` ☰
        deprecated ☰ `wikibase:DeprecatedRank` ☰ Typically used for wrong or out-of-date values. Wrong values may be connected with a «reason for deprecated rank» (P2241) relation, out-of-date values with a «start time» (P580) and «end time» (P582) relation.
      table }

      A statement is connected to a rank with the `http://wikiba.se/ontology#rank` (or `wikibase:rank`) relation.
      -
      The following query selects the three ranks:
code {
select
  distinct ?rank
{
#  []    <http://wikiba.se/ontology#rank>   ?rank .
   []     wikibase:rank                     ?rank .
}
code }
     → https://w.wiki/5obi[Run it]

    }
    { Claim

      The claim is the objective of a statement.

      Ranks and references do not belong the statement's claim.

    }
  }
  { Namespaces

    → https://www.wikidata.org/wiki/Help:Namespaces

  }
  { None and some

    A property can have the value *none* or *some*.

    *none* indicates that it is known that the given property was not available for the entity.

    *some* indicates what it is known that the given property was available, but we don't know its value.

  }

}
{ Misc

  URIs
    • Entities: → http://www.wikidata.org/entity/Q42
    • Properties: → http://www.wikidata.org/entity/P184
    • RDF in NTriples format: → http://www.wikidata.org/wiki/Special:EntityData/Q42.nt
    • RDF in → development/languages/JavaScript/objects/JSON[JSON] → http://www.wikidata.org/wiki/Special:EntityData/Q42.json

  { SERVICE wikibase:label

   `service wikibase:label` looks up labels, descriptions and/or alternative labels (AltLabel) for unbound variables whose names end in `Label`, `Description` and/or `AltLabel`:
code {
select
   ?country
   ?countryLabel
#  ?countryPrefLabel
   ?countryDescription
   ?countryAltLabel
#  ?altLabelDirect
{
    wd:Q188 wdt:P17 ?country .
 # ?country <http://www.w3.org/2004/02/skos/core#altLabel> ?altLabelDirect . filter(lang(?altLabelDirect) = 'en')
    service wikibase:label { bd:serviceParam wikibase:language "en" . }
}
code }
  → https://w.wiki/5z8u[Run it]

?  With this «service», it's not necessary to explicitly use `rdfs:label`, `skos:altLabel` and `schema:description`.

    { Default namespace: wd

      By default, `SERVICE wikibase:label` only supplies labels for entities in the `wd:` namepace.

      This can be changed by adding `?prop wikibase:directClaim ?p` to the query.

    }
    { Lexemes (Lemmas)

      Lexemes are not automatically looked up with this service. Thus, a
     `optional { ?x wikibase:lemma ?xLabel }` is required for lexemes:
code {
select
   ?x
   ?xLabel
{
   values (?x) {
      (wd:L296666)
      (wd:Q39    )
   }
 
   optional { ?x wikibase:lemma ?xLabel }
   service wikibase:label { bd:serviceParam  wikibase:language  'en,de,fr,rm' }
}
code }
      → https://w.wiki/5qS9[Run it]

    Search for lexemes in a few given languages:
code {
select
   ?lem
   (lang(?L) as ?lng)
{
  ?lem wikibase:lemma ?L .
  {
    select
      ?lem
    { 
      { ?lem wikibase:lemma "ding"@da } union
      { ?lem wikibase:lemma "ding"@en } union
      { ?lem wikibase:lemma "ding"@pt }
    }
  }
}
code }
    → https://w.wiki/5qUE[Run it]

    Search for a lexeme in any language:
code {
select
   ?lem
   (lang(?str)     as ?lng)
{
   ?lem wikibase:lemma ?str . filter(str(?str) = "ding")
}
code }
     → https://w.wiki/5qTr[Run it]

    }

  }
  { Wikidata Query Service (WDQS)

    WDQS is the server that executes wikidata queries formulated in → development/databases/query-languages/SPARQL.

  }

  { connecting wd:P… to their counterpart …:P… nodes

   `wikibase:directClaim` connects `wd:P…` to its counterpart `wdt:P…`.

    The following query returns `wdt:P10`:
code {
select * {
   wd:P10 wikibase:directClaim ?y  .
}
code }
    → https://w.wiki/5pVM[Run it]

    There are quite a few …:P… nodes which all can be reached from `wd:P…`. The following query returns `true`:
code {
ask {
   wd:P31   wikibase:claim                   p:P31 .
   wd:P31   wikibase:directClaim           wdt:P31 .
   wd:P31   wikibase:novalue              wdno:P31 .
   wd:P31   wikibase:qualifier              pq:P31 .
   wd:P31   wikibase:qualifierValue        pqv:P31 .
   wd:P31   wikibase:reference              pr:P31 .
   wd:P31   wikibase:referenceValue        prv:P31 .
   wd:P31   wikibase:statementProperty      ps:P31 .
   wd:P31   wikibase:statementValue        psv:P31 .
}
code }
   → https://w.wiki/5pgE[Run it]

  }
  { wikibase:badge

   `wikibase:badge` assigns a badge (such as «good article badge») to a Wikipedia article.

    The following query finds all(?) German featured articles:
code {
select
  ?aboutTxt
  ?about
  ?featuredArticle
{
   ?featuredArticle wikibase:badge        wd:Q17437796 ;
                    schema:inLanguage    "de"          ;
                    schema:about         ?about        .
  
   ?about           rdfs:label           ?aboutTxt     .

   filter(lang(?aboutTxt) = 'de')
}
order by lcase(?aboutTxt)
code }
  → https://w.wiki/5tjg[Run it]

    The following query lists the number of assigned badges for each badge:
code {
select
   ?cnt
   ?badgeLabel
   ?badge
{
   service wikibase:label { bd:serviceParam wikibase:language "[auto_language],en". }
   {
      select
         (count(*) as ?cnt)
         ?badge
      {
        []  wikibase:badge  ?badge 
      }
      group by
         ?badge
   }
}
order by
   ?badgeLabel
code }
    → https://w.wiki/5rGp[Run it]

  }
  { wikibase:Dump

    The types (`rdf:type`) of `wikibase:Dump` are `schema:Dataset` and `owl:Ontology`:
code {
select
   ?type
{
   wikibase:Dump  rdf:type   ?type
}
code }
    → https://w.wiki/5qyf[Run it]

    { TODO
code {
select
   ?a ?b
{
  wikibase:Dump ?a ?b .
}
code }

code {
select
   ?rel ?x
{
   values (?rel) {
     (<http://creativecommons.org/ns#license>)
     (schema:softwareVersion                 )
     (owl:imports                            )
   }

   wikibase:Dump ?rel ?x .
}
code }

    }

  }
  { wikibase:identifiers


   `wikibase:identifiers` indicates the number of identifiers for a topic.

    The following query finds the maximum number of identifiers for a topic (which, as of 2022-11-17, is 833):
code {
select
   (max(?nofIdentifiers) as ?maxNofIdentifers)
{
#
#  Use a subquery to prevent a timeout:
#
   {
      select distinct
         ?nofIdentifiers
      {
         [] wikibase:identifiers ?nofIdentifiers .
      }
   }
}
code }
   → https://w.wiki/5yqm[Run it]

    The following query finds all topics that have 833 identifiers:
code {
select
   ?x
{
   ?x wikibase:identifiers 833 .
}
code }
   → https://w.wiki/5yqo[Run it]

    As of 2022-11-17, this query returns one record: → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q88174316[Q88174316].

  }
  { wikibase:propertyType

    The data type of a property item (`wd:P…`) can be queried with `wikibase:propertyType`.

    As of September 2025, there are 18 property (or data) types as queried with → https://w.wiki/FTmo[this query]:
    table { rl
       9720 ☰ `wikibase:ExternalId`
       1707 ☰ `wikibase:WikibaseItem`
       677 ☰ `wikibase:Quantity`
       346 ☰ `wikibase:String`
       114 ☰ `wikibase:Url`
       87 ☰ `wikibase:CommonsMedia`
       68 ☰ `wikibase:Time`
       64 ☰ `wikibase:Monolingualtext`
       36 ☰ `wikibase:Math`
       22 ☰ `wikibase:WikibaseProperty`
       19 ☰ `wikibase:WikibaseSense`
       16 ☰ `wikibase:WikibaseLexeme`
       10 ☰ `wikibase:GlobeCoordinate`
       10 ☰ `wikibase:WikibaseForm`
       6 ☰ `wikibase:MusicalNotation`
       6 ☰ `wikibase:TabularData`
       3 ☰ `wikibase:GeoShape`
       2 ☰ `wikibase:WikibaseEntitySchema`
    table }


    A list of properties for a given property type is returned by the following query:
code {
select
   ?prop
   ?propLabel
{
   ?prop    wikibase:propertyType  <http://wikiba.se/ontology#GlobeCoordinate> .

    service wikibase:label { bd:serviceParam wikibase:language "en" . }
}
code }
  → https://w.wiki/5teD[Run it]



  }
  { wikibase:lemma

    The `wikibase:lemma` relations connects entities whose type is `ontolex:LexicalEntry` to strings:
code {
select
   ?sub
   ?typ
   ?lem
   (datatype(?lem) as ?dtp)
{
   ?sub wikibase:lemma ?lem .
   ?sub rdf:type       ?typ .
}
limit 100
code }
    → https://w.wiki/5qQs[Run it]

  }
  { wikibase:lexicalCategory

code {
select
   ?category
   ?categoryLabel
{
   hint:Query hint:optimizer "None".
   {
      select distinct
        ?category
     {
         [] wikibase:lexicalCategory ?category
     }
   }
   service wikibase:label { bd:serviceParam wikibase:language 'en,de,fr,de,ru,tg' . }
}
order by
   lcase(?categoryLabel)
code }
  → https://w.wiki/5ypu[Run it]

  }
  { wikibase:quantityAmount and wikibase:quantityUnit

code {
select
   ?itemLabel
   ?elevation
   ?unitLabel
{

   values (?item)
   {
      ( wd:Q46588    )  # Cordillera Kimsa Cruz : a mountain range in Bolivia
      ( wd:Q499164   )  # Ascraeus Mons         : a martian shield volcano
      ( wd:Q55615607 )  # Kalindi Pass          : highest and most adventurous trekking trail in India (almost 6000 M)
   }

   ?item        p:P2044                 ?eleStmts    .
   ?eleStmts    psv:P2044               ?eleValues   .

   ?eleValues   wikibase:quantityAmount ?elevation   .
   ?eleValues   wikibase:quantityUnit   ?unit        .

   ?item        rdfs:label              ?itemLabel   .
   ?unit        rdfs:label              ?unitLabel   .

   filter(lang(?itemLabel) = 'en')
   filter(lang(?unitLabel) = 'en')
}
code }
     → https://w.wiki/5ngi[Run it]

     TODO: what is the relation to `psv:Pnnn`:
code {
select
    ?amount
    ?unit
    ?unitLabel
{
  wd:Q153       p:P2102                 ?boilingPoint .
  ?boilingPoint psv:P2102               ?bolingValue  .
  ?bolingValue  wikibase:quantityAmount ?amount;
                wikibase:quantityUnit   ?unit         .

  service wikibase:label { bd:serviceParam wikibase:language "en". }
}
code }
     → https://w.wiki/FRZ2[Run it]

  }
  { wikibase:rank

    See → #wikidata-statements[statements].

  }
  { wikibase:sitelinks

code{
select
   (max(?nofSitelinks) as ?maxNofSitelinks)
{
#
#  Use a subquery to prevent a timeout:
#
   {
      select distinct
         ?nofSitelinks
      {
         [] wikibase:sitelinks ?nofSitelinks .
      }
   }
}
code }
   → https://w.wiki/5yr3[Run it]

code {
select
   ?x
{
   ?x wikibase:sitelinks 873 .
}
code }
    → https://w.wiki/5yr5[Run it]

    As of 2022-11-17, the topic with the most site links is → http://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q105429923[Q105429923]

  }
  { wikibase:* TODO

   `wikibase:statements`, `wikibase:quantityNormalized`, `wikibase:grammaticalFeature`,
   `wikibase:quantityLowerBound`, `wikibase:quantityUpperBound`, `wikibase:geoGlobe`, `wikibase:geoPrecision`, `wikibase:geoLongitude`, `wikibase:geoLatitude`.
   `wikibase:timeCalendarModel`, `wikibase:timeTimezone`, `wikibase:timePrecision`, `wikibase:timeValue`

  }
  { schema:about

   `schema:about` links a Wikipedia URL to a «wd:…» number.

    The following query translates the Hebrew Wikipedia page of Zurich to → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q72[Q72]:
code {
select
   ?wdNr
{
   <→ https://he.wikipedia.org/wiki/%D7%A6%D7%99%D7%A8%D7%99%D7%9A[https://he.wikipedia.org/wiki/%D7%A6%D7%99%D7%A8%D7%99%D7%9A]> schema:about ?wdNr .
}
code }
    → https://w.wiki/5nbd[Run it]

   `schema:about` can be combined with `schema:isPartOf` to query the Wikipedia URL of a given topic (Q-Nr) in a given Wikipedia language:
code {
select
   ?wikipediaURL
{
   ?wikipediaURL schema:about     wd:Q72                        .
   ?wikipediaURL schema:isPartOf <https://he.wikipedia.org/>    .
}
code }
    → https://w.wiki/5nbq[Run it]

   { Query all German pages related to wd:Q72:
code {
select * {
   ?page schema:about      wd:Q72 .
   ?page schema:inLanguage "de"
}
code }

      In September 2025, this query returned:
        • → https://de.wikinews.org/wiki/Kategorie:Zürich
        • → https://de.wikipedia.org/wiki/Zürich>
        • → https://de.wikiquote.org/wiki/Zürich>
        • → https://de.wikisource.org/wiki/Zürich>
        • → https://de.wikivoyage.org/wiki/Zürich>

    }

  }
  { schema:Article

   `schema:Article` is the type (`rdf:type`) of a Wikipedia article URL.
    -
    Thus, the following query returns `true`:
code {
ask {
  <→ https://en.wikipedia.org/wiki/Wikidata[https://en.wikipedia.org/wiki/Wikidata]>  rdf:type  schema:Article .
}
code }
    → https://w.wiki/5rGG[Run it]

  }
  { schema:dataset

    There is only one record returned by the following query. The value of `?subj` in that record is `wikibase:Dump`.
code {
select *
{
  ?subj rdf:type schema:Dataset .
}
code }
    → https://w.wiki/5qyY[Run it]

  }
  { schema:inLanguage

   `schema:inLanguage` relates a Wikimedia(?) article to a language.

  }
  { schema:name

   `schema:name` relates a *Wikimedia URL* to a label.

    The following query finds the URLs that are associated with *August Piccard in French* and *Oracle Database in English*.
code {
select
   ?name
   ?wikimediaURL
{

   values (?name) {
     ("Auguste Piccard"     @fr)
     ("Oracle Database"     @en)
   }

   ?wikimediaURL schema:name ?name
}
code }
    → https://w.wiki/5pif[Run it]

   The following query finds the label that is associated with a given Wikimedia URL
code {
select
  ?label
 (lang(?label) as ?lang)
{
   <→ https://de.wikipedia.org/wiki/London[https://de.wikipedia.org/wiki/London]>  schema:name ?label .
}
code }
   → https://w.wiki/5pmV[Run it]


  }
  { schema:isPartOf

?   The `schema:isPartOf` relation connects a Wikimedia URL to a wikimedia project.

    The following query returns `<https://de.wikisource.org/>`
code {
select ?partOf
{
   <→ https://de.wikisource.org/wiki/Das_Newe_Testament_Deutzsch[https://de.wikisource.org/wiki/Das_Newe_Testament_Deutzsch]> schema:isPartOf ?partOf
}
code }

    The following query uses SPARQL's `distinct` operator to select *all* wikimedia(?) related websites.
code {
select distinct ?partOf
{
   $item schema:isPartOf ?partOf
}
order by
   ?partOf
code }
   → https://w.wiki/5o4C[Run it.]

     Compare `schema:isPartOf` with the P361 («part of») relation.

  }
  { schema:description

code {
select
   ?descr
  (lang(?descr) as ?lang)
{
   wd:Q39 schema:description ?descr .
}
code }

  }
  { schema:* TODO:

    `schema:modified`, `schema:version`, `schema:description`

  }
  { Combining some schema:* relations

code {
select
   ?term
  (lang(?term) as ?termLang)
   ?lang
   ?wikimediaURL
   ?wikidataID
   ?project
{

   values (?term) {
     ("Gift"@en)
     ("Gift"@de)
   }

   ?wikimediaURL schema:name       ?term       .
   ?wikimediaURL schema:about      ?wikidataID .
   ?wikimediaURL schema:isPartOf   ?project    .
   ?wikimediaURL schema:inLanguage ?lang       .
  
}
code }

  }
  { rdfs:label

    The `rdfs:label` predicates assigns a text and a language to a node. The language ID of the added text can be quried with the `lang(…)` function.

    The following query selects translations of «Switzerland» and their language ID and order them by the language ID:
code {
select
  (lang(?label) as ?langId)
   ?label
{
   wd:Q39   rdfs:label  ?label .
}
order by
   ?langId
code }
    → https://w.wiki/5pFa[Run it]


    `lang(…)` can be used in a `filter` clause to limit the result to a given language (in the following example to *Bengali*, whose ID is *bn*):
code {
select
   ?label
{
   wd:Q39   rdfs:label  ?label .
   filter( lang(?label) = 'bn' )
}
code }
    → https://w.wiki/5pFe[Run it]


    See also the `skos:altLabel` predicate.

  }
  { rdf:type

    The value for `?type` of any `?x rdf:type ?type` triplet is one of:
    table { ll
      `wdno:P…` ☰ 
       `schema:Article` ☰ The URL of a Wikipedia article
       `schema:Dataset` ☰  Only one triplet!
       `wikibase:BestRank` ☰ Something like `wds:Q103-08172073-0D68-4629-BE18-9CF0DD561EB1`
       `wikibase:GeoAutoPrecision` ☰ Something like `wdv:8000239f9ef48fc7fb846097dc6a3e12`
       `wikibase:GlobecoordinateValue` ☰ Something like `wdv:8000047f8684a2c2aebdc7ba7c394403`
       `wikibase:Property` ☰ The type of some(?) `wd:P…`
       `wikibase:QuantityValue` ☰ Something like `wdv:800000dc9c08f381edb20359f260af3f`
       `wikibase:TimeValue` ☰ Something like `wdv:8000170412b9aeb739d076fed903a0ff`
       `owl:Class` ☰ The type of `wdno:P…`
       `owl:DatatypeProperty` ☰ The type of *some* `wdt:P…`
       `owl:ObjectProperty` ☰ The type of *some* `wdt:P…`
       `owl:Ontology` ☰  Only one triplet
       `owl:Restriction` ☰ The type of something similar to `http://www.wikidata.org/.well-known/genid/83cf7cf86e26b18479fbe7609e990e0e`
       `ontolex:Form` ☰ Forms of lexemes? (for example `wd:L10033-F2`)
       `ontolex:LexicalEntry` ☰ Lexemes (for example `wd:L484`)
       `ontolex:LexicalSense` ☰ For example `wd:L17815-S1`
    table }

  }
  { owl:Ontology

    There is only one record returned by the following query. The value of `?subj` in that record is `wikibase:Dump`.
code {
select *
{
  ?subj rdf:type owl:Ontology .
}
code }
    → https://w.wiki/5qyb[Run it]

  }
  { prov:wasDerivedFrom

    `prov:wasDerivedFrom` connects `wds:*` to `wdref:*`.

  }
  { skos:altLabel

   `skos:altLabel` assigns a *list of aliases* to a node.

    In a wikidata entry page, these aliases appear under the column *Also known as*.

code {
select
   ?alias
{
   wd:Q39   skos:altLabel  ?alias .
   filter( lang(?alias) = 'en' )
}
code }
    → https://w.wiki/5pH9[Run it]

    See also the `rdfs:label` predicate.


  }
  { ontolex:* TODO

   `ontolex:representation`, `ontolex:lexicalForm`

  }
  { dct:* TODO

   `dct:language`

  }
  { Lexemes

    Query the grammatical gender (→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/P5185[P5185]) of the german word *Aprikose*.
code {
select
   ?lexem
   ?gender
{
   ?lexem      rdf:type       ontolex:LexicalEntry .
   ?lexem      dct:language   wd:Q188              . # Q188:  German
   ?lexem      wikibase:lemma ?text                . filter(str(?text) = "Aprikose")
   ?lexem      wdt:P5185      ?gender_             . # P5185: grammatical gender
   ?gender_    rdfs:label     ?gender              . filter(lang(?gender) = 'de')
}
code }
  → https://w.wiki/5nc3[Run it].

  }
  { wdt:P…

    wdt:P… connects a node to its so-called «truthy value».

  }
  { p: connect wd:Q… to wds:…

   A «p:…» relation connects a «wd:Q» number to a «wds:…» node (→ https://w.wiki/5nf3[Wikidata Query Service]):
code {
select
   ?wds
   ?rel
   ?obj
{
   wd:Q544  p:P2670  ?wds .  # Q544 = Solar System
   ?wds     ?rel     ?obj .
}
code }

  }
  { ps: connect wds: to simple value

    A «ps:…» relation connects a «wds:…» node to a *simple value*. Apparently, simple values are «Q numbers»
    -
    The following query sort of reverses the above query (→ https://w.wiki/5nf9[Wikidata Query Service]):
code {
select
   ?wd
{
   wds:Q544-1edcc7b8-4eb3-28d9-35b5-b6ff5bbc8e38 ps:P2670 ?wd .
}
code }

    Note that a «wdt:» relation connects a «wd:» node to a *simple value*.

  }
  { p: , ps: and pq:

    The following query prints a line chart of the population growth in Swizerland since 1970 and tries to demonstrate the combined usage of `p:`, `ps:` and `pq:` relations.

    First, `wd:Q39 p:P1082 ?populationStmt` extracts all statements that are relate Swizterland (Q39) to its population (`p:1082`).
    -
    Then, the `pq:P585` relation extracts each statement's year, and `ps:P1082` the statement's population value. It is unclear to me why I have to use `pq:` for one relation an `ps:` for the other one.
    -
    Finally, the `filter` condition only selects values where the year is greater or equal to 1970 (→ https://w.wiki/5nfq[Run it]):
code {
#defaultView:LineChart
select
   ?year
   ?population
{
  wd:Q39          p:P1082  ?populationStmt .
  ?populationStmt pq:P585  ?year           ;
                  ps:P1082 ?population     .
  filter(year(?year) >= 1970)
}
order by
   ?year
code }

    I belive that `pq:` stands for «property qualifier» and `ps:` for «property statement».

    Note: this example also demonstrates a weakness of wikidata: no population values are shown for the years 2015, 2016 and after 2017,
    probably, because these values were imported before 2018 and are not maintained anymore.

  }
  { psn:

    TODO: does `psn:` stand for «normalized property statement»?

  }
  { pqv:

    TODO: does `pqv:` stand for «property qualifier value»?

  }
   { P31 / instanceOf

     P31 connects an object to the class of which it is an instance.

     The following query finds the 100 classes with the most objects that belong to that class:
code {
select
   ?cnt
   ?xLabel
   ?x
with {
   select
  (count(*) as ?cnt)
   ?x 
  {
     [] wdt:P31 ?x .
  }
  group by ?x
  order by desc(?cnt)
  limit 100
}
   as %I
{
   include %I 
   service wikibase:label { bd:serviceParam wikibase:language "en" . }
}
order by
   desc(?cnt)
code }
    → https://w.wiki/5r7r[Run it]

   }
   { DESCRIBE

    `descibe <entity>` returns all triplets where `<entity>` is subject or object:
code {
describe <http://www.wikidata.org/entity/Q72>
code }
     → https://w.wiki/5nmB[Run it]

  }
  { Wikidata categories

    A Wikidata category is an instance of `Q4167836`.

    As of October 2022, there are over 5 million categories:
code {
select
   (count(*) as ?cntWikidataCategories)
{
   ?category  wdt:P31  wd:Q4167836 .
}
code }
    → https://w.wiki/5ocA[Run it]

  }
  { Disambiguation pages

    A so-called disambiguation page should be an instance of → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q4167410[`wd:Q4167410`].

    The following query verifies if → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q399841[`wd:Q399841`] (→ https://www.wikidata.org/wiki/Q399841[Oracle]) is a disambiguation page:
code {
ask {
   wd:Q399841  wdt:P31  wd:Q4167410 .
}
code }

    See also «Wikipedia article covering multiple topics» (Q21484471), «main subject» (P921) and «has parts» (P527)

  }
  { RDFS and OWL terms

    "
      The Wikidata schema avoids direct use of RDFS or OWL
      terms and redefines many of them, e.g. wkd:P31
      defines a local property similar to rdf:type.
      There are attempts to connect Wikidata properties
      to RDFS/OWL and provide alternative exports of
      Wikidata data.
    " [ → https://www.semantic-web-journal.net/system/files/swj1462.pdf[Wikidata through the Eyes of DBpedia] ]

  }
  { Finding an Wikidata item's corresponding DBpedia resource

    On the → development/Data/open/DBpedia SPARQL endpoint, a Wikidata item's corresponding DBpedia resource can be queried like so:
code {
select
   ?sub
{
   ?sub  owl:sameAs  <http://www.wikidata.org/entity/→ https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/entity/Q507459[Q507459]> .
}
code }

  }
}
{ Wikidata Query Service

  { Default View

    The → https://query.wikidata.org/[Wikidata Query Service] allows to emit the selected data in various formats. The format needs to be specified as comment:
    table { ll
      `#defaultView:AreaChart` ☰
      `#defaultView:BarChart` ☰
      `#defaultView:BubbleChart` ☰
      `#defaultView:Dimensions` ☰
      `#defaultView:Graph` ☰
      `#defaultView:ImageGrid` ☰
      `#defaultView:LineChart` ☰
      `#defaultView:Map` ☰
      `#defaultView:ScatterChart` ☰
      `#defaultView:Timeline` ☰
      `#defaultView:Tree` ☰
      `#defaultView:TreeMap` ☰
    table }

    { LineChart

      The following example creates a line chart. For simplicity, the rendered values are hardcoded. (→ https://w.wiki/5nfM[Run it]).
code {
#defaultView:LineChart
select ?x ?y {
   values (?x ?y) {
      ( 1  20)
      ( 6  23)
      ( 9  21)
      (11  19)
      (14  20)
      (15  22)
      (17  24)
   }
}
code }

    }
    { Map

      If a query result returns coordinates, `#defaultView:Map` will create a map:

      The following query produces a map with *castles* (Q23413) or *castle ruins* (Q17715832) located in the Kanton Zurich (Q11943):
code {
#defaultView:Map
select
 #
 # Use distinct to make all points on the map equally sized.
 # Some nodes are linked with both, Q23413 and Q17715832, and thus
 # would be drawn with a bigger point.
 #
   distinct
  ?name
  ?coord
{
   values (?castleType) {
      ( wd:Q23413    )
      ( wd:Q17715832 )
   }

   ?castle  wdt:P31    ?castleType ;
            p:P131     ?locStmt    ;
            wdt:P625   ?coord      ;
           rdfs:label  ?name       .

   ?locStmt ps:P131     wd:Q11943  .

   filter(lang(?name) = 'de')
}
code }
     → https://w.wiki/5oVs[Run it]

     `"Point(lon lat)"^^geo:wktLiteral"` is a coordinate literal (note: the order longitude before latitude is different from → misc/ISO/6709).
     -
     Such literals allow to draw a «hardcoded» point on a map:
code {
#defaultView:Map
select
  *
{
   values (?coord ?text) {
       ( "Point(-6.4456011 49.872861 )"^^geo:wktLiteral  "Bishop Rock"   @en )
       ( "Point(-6.4172637 49.878124 )"^^geo:wktLiteral  "Isles of Scily"@en )
   }
}
code }
     → https://w.wiki/5oUb[Run it]

     With `#defaultView:Map{"layer": "?var"}`, it's possible to create a layered map. The value of `?var` determines in which layer an item is put. Additionally, each layer draws
     its items in a different color.
     -
     The following query draws a map of Switzerland where the municipalities are colored depending on their suffixes. (With the chosen suffixes here, the map is only really
     interesting for the German part of Switzerland):
code {
#defaultView:Map{"layer": "?suffix"}
select
   ?munic
   ?name
   ?coord
  (if(regex(?name, 'wil$'  ), '-wil',
   if(regex(?name, 'wilen$'), '-wilen',
   if(regex(?name, 'ikon$' ), '-ikon',
   if(regex(?name, 'iken$' ), '-iken',
   if(regex(?name, 'rach$' ), '-rach',
   if(regex(?name, 'ingen$'), '-ingen',
   if(regex(?name, 'au$'   ), '-au',
   if(regex(?name, 'bach$' ), '-bach',
   if(regex(?name, 'berg$' ), '-berg',
    "*")))))))))  as ?suffix)
with { # Use named subquery (which is guaranteed to be run only once) to improve performance
      select
         ?munic
        (replace(?name, '(.*) \\w\\w$', '$1') as ?name)  # Remove occasional Canton abbreviation (for example 'Oberdorf BL')
      {
         ?munic  wdt:P31     wd:Q70208 ;
                 wdt:P625   ?coord     ;
                 rdfs:label ?name .
        filter(lang(?name) = 'de')
      }
} as %municipalities
where {
   include %municipalities
   ?munic       wdt:P625   ?coord     .
}
code }
     → https://w.wiki/5pWb[Run it]

    }

  }

}
{ Some queries

  { Mountains higher than 4000 meters in Switzerland

   → https://w.wiki/5ngJ[Run it]
code {
select
   ?elevation
   ?name
   ?mountain
{

  ?mountain wdt:P31      wd:Q8502   ; # ?mountain is an "instance of" (P31) a "mountain" (Q8502)
            wdt:P17      wd:Q39     ; # ?mountain has "country" (P17) "Switzerland" (Q39)
            wdt:P2044    ?elevation ; # P2044: "elevation above sea level"
            rdfs:label   ?name      . # Use rdfs:label to find the mountain's name

            filter(?elevation >= 4000)
            filter(lang(?name) = 'de')
}
order by
  ?elevation
code }

  }
  { Most common relations

    The following query tries to determine the most common relations.

    In order to prevent a query timeout error, we have to use a *nested query* to select a sample of 10 Million relations before we group and count them:
code {
select
   ?rel
   (count(?rel) as ?cnt)
{
   select ?rel
   {
      ?x  ?rel ?y .
   }
   limit 10000000
}
group by
   ?rel
order by
   desc(count(?rel))
limit
   100
code }
→ https://w.wiki/5nhR[Run it]

    On 2022-10-08, the query returned
    table { lr
      `rdf:type` ☰ 2150595
      `wikibase:rank` ☰ 1307831
      `schema:inLanguage` ☰ 900424
      `schema:name` ☰ 900424
      `schema:isPartOf` ☰ 900424
      `schema:about` ☰ 888219
      `prov:wasDerivedFrom` ☰ 793082
      `pq:P585` ☰ 76617
      `pqv:P585` ☰ 76615
      `ps:P31` ☰ 42471
      `pq:P580` ☰ 34544
      `pqv:P580` ☰ 34498
      `ps:P1082` ☰ 33245
      `psv:P1082` ☰ 33244
      `pq:P459` ☰ 32322
      `ps:P106` ☰ 30558
      `ps:P646` ☰ 29962
      `psn:P646` ☰ 29962
      `ps:P18` ☰ 22791
      `ps:P373` ☰ 21941
      `pq:P582` ☰ 21832
      `pqv:P582` ☰ 21598
      `ps:P47` ☰ 18965
      `pq:P1810` ☰ 18165
      `psn:P214` ☰ 15899
    table }

    2022-11-12: it seems that the subquery with the `limit` clause skewed the data. The following query
    counts (assumedly) better:
code {
select
   ?cnt
   ?rel_
   ?relLabel
with {
#
#  Use named subquery (which is guaranteed to be run only once) to improve performance
#
   select
       ?rel_
      (count(*) as ?cnt)
   {
      [] ?rel_ [] 
   }
   group by ?rel_
   order by desc(?cnt)
   limit 400             # not every relation will be matched below...
} as %rels
where {
   include %rels .
   optional { ?rel wikibase:directClaim ?rel_ . 
              ?rel rdfs:label ?relLabel . filter(lang(?relLabel) = 'en') . }
}
order by desc(?cnt)
code }
    → https://w.wiki/5x9m[Run it]

    The following query builds on the previous one, but only returns relations for which an english label is
    defined:
code {
select
   ?cnt
   ?rel_
   ?relLabel
with { # Use named subquery (which is guaranteed to be run only once) to improve performance
   select
       ?rel_
      (count(*) as ?cnt)
   {
      [] ?rel_ [] 
   }
   group by ?rel_
   order by desc(?cnt)
   limit 400             # not every relation will be matched below...
} as %rels
where {
   include %rels .
   ?rel wikibase:directClaim ?rel_ . 
   ?rel rdfs:label ?relLabel . filter(lang(?relLabel) = 'en') .
}
order by desc(?cnt)
code }
   → https://w.wiki/5x9o[Run it]


  }
  { All objects of a given node

    The following query returns all relations of a given node (here: Switzerland = Q39).
    -
    In order to be more readable, the query returns a relation's label.
    -
   `?relType` corresponds to the property type expected by the relation. 
    -
    Because some relations point to another node, other relations just to a value,
   `coalesce(…)` returns either the label of the referenced node or the value.

code {
select
   ?relText
   (coalesce(?xText, ?x) as ?obj)
   ?rel_
   ?relType
#  ?x
#  ?xText
{

#  wd:Q35120  ?rel                   ?x       .
   wd:Q39     ?rel                   ?x       .

   ?rel_      wikibase:directClaim   ?rel     .
   ?rel_      rdfs:label             ?relText . filter(lang(?relText) = 'en')
   ?rel_      wikibase:propertyType  ?relType .
  
  
   optional {
   ?x         rdfs:label             ?xText   . filter(lang(?xText  ) = 'en')
   }
}
order by
   lcase(?relText)
code }
     → https://w.wiki/5pay[Run it]

  }

}
{ TODO

  { wd:Q23958852

    wd:Q23958852 («Variable-order class») is interesting because it is an instance (wdt:P31) of itself. The following query returns `true`:
code {
ask {
   wd:Q23958852  wdt:P31  wd:Q23958852 .
}
code }
    → https://w.wiki/5pVK[Run it]

  }

  { Queries on the Wikimedia Commons endpoint

    The *Wikimedia Commons* endpoint is → https://commons-query.wikimedia.org/.

code {
select *
{
   ?x ?y ?z 
   filter (?y != schema:dateModified)
}
limit 100
code }
    → https://w.wiki/5xYu[Run it]

code {
select *
{
   ?x
   ps:P921        # Main subject
   wd:Q28048087 . # Benjamin Franklin
}
code }
   → https://w.wiki/5xZ2[Run it]


code {
select * {
  ?x schema:contentUrl <→ https://upload.wikimedia.org/wikipedia/commons/f/fd/Matterhorn_from_Switzerland.jpg[https://upload.wikimedia.org/wikipedia/commons/f/fd/Matterhorn_from_Switzerland.jpg]> ;
     ?rel               ?obj
}
code }
   → https://w.wiki/5xZ9[Run it]

  }
  { owl:onProperty

   `owl:onProperty` connects something like `<http://www.wikidata.org/.well-known/genid/…>` to `wdt:P…`:
code {
select * { ?well_known_genid owl:onProperty ?wdt }
code }

    The `rdf:type` of `?well_known_genid` is `owl:Restriction`:
code {
select * {
   ?well_known_genid owl:onProperty ?wdt .
   optional {  ?well_known_genid rdf:type ?type }
   filter (?type != owl:Restriction)
}
code }

   In addition, `?well_known_genid` relates to `owl:Thing` via `owl:someValuesFrom`:
code {
select * {
   ?well_known_genid owl:onProperty ?wdt .
   optional {  ?well_known_genid owl:someValuesFrom ?valFrom }
   filter (?valFrom != owl:Thing)
}
code }


  }

}

sa:

  Querying the Wikidata SPARQL endpoint with
    • → Windows/PowerShell/command-inventory/noun/restMethod/invoke#invoke-restMethod-wikidata[PowerShell's `invoke-restMethod` cmdlet]
    • → development/web/php/snippets/cURL/wikidata-SPARQL[PHP's cURL library]
    • With → development/languages/Python[Python's] library → development/languages/Python/libraries/requests#py-requests-wikidata[request] (See also → development/languages/Python/libraries/tabulate#pylib-tabulate-wikidata)

  → https://opendata.renenyffenegger.ch/Wikimedia/Wikidata/cytoscape.php[An experiment] that draws some Wikidata triplets with
  → development/web/libraries/Cytoscape_js.

  → development/Data/open/Wikimedia
