$ .htaccess

{ Create a 301 (Moved permanently) redirection


code {
RewriteEngine On
Redirect 301 /path/to/ressource.html https://renenyffenegger.ch/notes/development/Apache/Server/htaccess
code }

  Note: the redirected path seems to be required to be stated absolutely, even if the `.htaccess` files is placed
  in the same directory where the redirected ressource is stored.

  See also → development/web/HTML/redirection.

}
{ Enable php within html documents #enable-php

  The following snippet enables → development/web/php within html documents:
code {
AddHandler application/x-httpd-php .html .htm
code }

  In previous(?) or other(?) versions of Apache and/or → development/web/php, the following handler needed to be installed:
code {
AddHandler php5-fastcgi .htm .html
code }

  On yet another Apache Server, I had to use:
code {
SetHandler php-script
code }

}
{ Serve handler.php no matter what was requested

With the following snippet, any request will be served by `handler.php`.

code {
RewriteEngine on
RewriteRule ^.* handler.php
code }

Within the → development/web/php[PHP] script, the requested → development/web/URI-URL-URN-IRI-URC#uri[URI] can be accessed with `$_SERVER['REQUEST_URI']`.

}
{ DirectoryIndex

  If → development/web/URI-URL-URN-IRI-URC#url[URL] is a path only, Serve *file.one* if existing else serve *file.two* (if existing).

code {
DirectoryIndex file.one file.two
code }

}
{ Force files without suffix to be served as text/html files

Without suffix, Apache is apparently unable to determine a → development/web/Multipurpose-Internet-Mail-Extensions[MIME] type.

In order to force the MIME type for files without suffix, the following snippet should do:

code {
<FilesMatch "^[^\.]+$">
  ForceType text/html
</FilesMatch>
code }

}
{ Create 404 for directory and subdirectory

code {
RewriteEngine On
ErrorDocument 404 https://url.xyz/path/to/404-document.html
Redirect 404 /path/of/directory/to/create/404/for
code }
}
{ Let Apache serve suspicious files with names like wget, too.

For security reasons, Apache does by default not really like to serve URIs that contain the word → tools/wget etc.

This behaviour can be turned off with the following snippet:

code {
<IfModule mod_security.c>
  SecFilterEngine Off
  SecFilterScanPOST Off
</IfModule>
code }

}
{ Redirect http to https

Redirect a request to `http://abc.yz/foo/bar.html` to `https://abc.yz/foo/bar.html`.

In order to take effect for any url, the following .htaccess must pe put in the root directory.
-
The `R=301` indicates a permanent redirect. Just an `R` would default to `302` (=Found). The `L` indicates the last rule.
-
Since `%{REQUEST_URI}` apparently always starts with a slash, there is no need for a slash between the servername and the URI.
code {
RewriteEngine On
RewriteCond %{SERVER_PORT} 80
RewriteRule ^(.*)$ https://renenyffenegger.ch%{REQUEST_URI} [R=301,L]
code }

The following snippet didn't work in subdirectories. Apparently the → development/regular-expressions[regular expression] only matches the last part of the URI:
code {
RewriteEngine On
RewriteCond %{SERVER_PORT} !^ 443 $
RewriteRule (.*) https://%{HTTP_HOST}/$1 [L]
code }

}
sa:

  A corrupt `.htaccess` file might lead to a → development/web/HTTP/status-code[500 - Internal Server Error HTTP status code].

  The `AllowOverride` directive in the → development/Apache/Server/httpd_conf controls the set of directives that
  can be placed in a .htaccess file.
