
The essential and simple concept of SOA is … *service*. Usually the services are located on a distributed architecture.

Services are typically accessed with
  • → development/web/service/REST
  • → development/web/service/SOAP
  • AMQP
  • JMS
  • MSMQ
  • RMI
  • etc.


Services are autonomous and stateless (?). Their interfaces are documented and separated from the cross-cutting concerns of the implementation

One option to implement services are web services.

Some enterprise architects believe that SOA can help businesses respond more quickly and more cost-effectively to changing market conditions.

{ Perceived advantages

  • Speed of development: monoliths take longer to build and deploy
  • Flexibility of technology: Not tied to one technology/provider until phase out.
  • Supports agile methodology
  • Scalability: grade up underperforming service.
  • Security. (Oh, really???)

}
{ Trade offs

  Service orientation is one of the most appraised paradigms in software engineering and enterprise IT. Service based architectures are generally
  views as a major improvement over *monolithic applications*.

  However, the flexibility of service architecture comes with a price that needs to be addressed when deisigning them:
    • Increased complexity
    • Definition of → #soa-contract[contracts]
    • Availability
    • → #soa-security[Security]
    • → #soa-transaction-management[Transaction management]

}
{ Properties of a service

  • It represents a business activity with a specified outcome
  • It is self contained
  • It is a black box for its consumers
  • It may consist of underlying services

}
{ Service types

  • Business services: Coarse-grained. Usually → development/XML, → development/web/service/WSDL or BPEL based. Used for business operations.
  • Enterprise services: Implement the functionality defined by business services. Rely on application and infrastructer services.
  • Application services: Bound to a specific application
  • Infrastructure services: non functional tasks such as authentication, auditing, security, and logging. 

}
{ Contract #soa-contract

  The *service contract* is the *agreement* between a service and a consumer (client).
  
  Two types of contracts:
    • service-based contracts (the service owns the contract)
    • consumer-driven contracts (contract is established by collaboration)

  Contracts should be versioned. Two types of versioning strategy:
    • homogeneous versioning: version number is embedded in contract
    • heterogeneous versioning: better suited for consumer-driven contracts

}
{ Architecture

  Layers:
    • Services/APIs
    • Application
    • Application Server
    • Managed Runtime Environment
    • Operating System
    • Hypervisor
    • Storage
    • Network
    • Hardware

}
{ Roles

  • Service provider
  • Service broker (or registry, repository)
  • Service consumer (requester)

}
{ Implementation

  A SOA can be implemented with Web services such as SOAP, REST, CORBA, Jini.

}
{ Security #soa-security

  • Authentication
  • Authorization

  With micro-services, security is quite a challenge: no middleware helps because each service must handle authentication and authorization by itself.

}
{ Transaction management #soa-transaction-management

  Service based architectures typically rely on BASE rather than → development/databases/common/ACID.

}
{ Orchestration vs choreography #orchestration-vs-choreography

    • Orchestration: workflow driven
    • Choreography: loosly copuled, peer to peer. Better suited for → development/Cloud

  Orchestration relies on a central system to control and call (micro-)services to complete a task.
  
  With Choreography, each (micro-)service acts as a state machine and reacts based on the input from other services.

  Orchestration services are often called synchronously, choreography services asynchronously.


}
{ Design principles #soa-design-principles

  • Standardized service contract
  • Service loose coupling
  • Service abstraction
  • Service reusability
  • Service autonomy
  • Service statelessness
  • Service discoverability
  • Service composability
  

}
{ Service vs Components

  A component is a piece of software to be used locally by another piece of software. So, a component might be a DLL,
  jar file, object file, an imported source etc.)

  A service is used remotely via a well defined interface (such as → development/web/service[web service], RPC call etc.) in a distributed system.

}
{ TODO

  SOMF: the service oriented modeling framework.

  Protocols

  Microservices

  { SOA governance

    SOA governance extends IT governance with the focus on the *lifecycle* of services. Thus, it tries to make sure that the business value of SOA is maintained.

  }

}
{ Design patterns #soa-design-pattern

  10 important design patterns:
    • Agnostic Services
    • Agnostic Service Declaration
    • Atomic Service Transaction
    • → development/Software-design/Enterprise-Bus#enterprise-bus-service[Enterprise Service Bus]
    • Service Facade
    • Service Callback
    • Multiple Service Contracts
    • Authentication Broker
    • Message Origin Authentication
    • Message Screening

}
sa:
  → development/web/service/BPEL
