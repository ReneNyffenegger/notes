$ Software design patterns

A pattern provides a working solution to a common problem

The Gang of Four (Gof) established 23 well known design patterns.

{ Types


  Three types of patterns. (Note: ~Interface~, needed for encapsulation, decoupling the clients from the interface realizationis, a non standard pattern)

  { Creational

    • Abstract factory
    • ~Builder~: Separate the construction of a complex object from its representation
    • ~Factory method~: might be considered a simplified *Builder*.
    • Prototype
    • ~Singleton~: Ensure that a class has only *one* instance.

  }
  { Structural

    • ~Adapter~: Converts one interface to another so that it matches what a client expectds (for example when talking to legacy backend systems).
    • ~Bridge~: (Not to be confused with the Adapter pattern)
    • Composite
    • ~Decorator~: Add behaviour to an object (possibly a *Facade*) so as to enhance it. (Aspect oriented programming)
    • ~Facade~: Provides a simplified interface. decouples independent classes, and more important, decreases (makes the interface more coarse grained) the granularity
    • Flyweight
    • ~Proxy~: A class that controls access to another.

  }
  { Behavioral

    • Chain of responsibility
    • ~Command~: Represent an action as an object.
    • Interpreter
    • Iterator
    • Mediator
    • Memento
    • ~Observer~: allows for concurrent operations. The observer just waits for the observable to emit values.
    • State
    • ~Strategy~: Encapsulate a family of related algorithms.
    • Template method
    • Visitor

  }

}
{ VS

  { Adapter vs Bridge

"
  Adapter makes things work after they're designed; Bridge makes them work before they are.
" [ GoF, p219 ]

  }
  { Adapter vs Decorator

    A Decorator typically addes functionality to a wrapped object: logging, encryption, formatting etc. 

  }

}
sa:
  C. Alexander: → https://en.wikipedia.org/wiki/A_Pattern_Language[A pattern language]
