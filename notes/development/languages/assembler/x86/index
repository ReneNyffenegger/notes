$ Assember (x86)

Since the x86 has evolved over three decades during whicht it had to respond to different »market forces« while maintaining *backward compatiblity*, the x86 assembly language is charged with an immense legacy:
  • 16 bit real mode
  • real mode within *virtual 8068 mode* (x86-64 discontinued *virtual protected mode*)
  • protected mode (16 or 32 bits)
  • enhanced mode (64 bit)

{ Registers

  eax, ebx, ecx, edx: 32 bit general purpose register (GPR)
  -
  ah, bh, ch, dh: Upper 16 bits of respective GPRs
  -
  al, bl, cl, dl: Lower 16 bits of respective GPRs
  -
  64 Bit version like 32 bit, but with RAX, RBX …
  
  The eax register is used to return values from functions. it has also a special semantic for arithmic functions.
  -
  ecx has special semantic for looping functions.
  
  esp: stack pointer
  -
  ebp: basepointer, can be used in high level languages for to reference function parameters and local variables on the stack.
  
  esi: source for string operations
  - 
  edi: destination for string operations
  -
  Some instructions, such as `rep stosb`, `rep movsb` or `rep scasb`, can only be done using these two registers.

  eip: intstruction pointer

  eflags

  Control flags: they control the → hardware/CPU[CPU]'s operation.

  Status flags:
    • carry flag (CF): set if result of *unsigned arithmetic* operation is too large for destination.
    • overthrow flag (OF): set if result of *signed arithmetic* operation is too large for destination.
    • sign flag (SF): set if arithmetic or logical operation results in a negative outcome.
    • zero flag (ZF): set if result of arithmetic or logical operation is zero.
    • auxiliary carry flag (AC)
    • parity flag (PF)


  
  Registers that are (apparently exclusively) used in *real mode*:
   • cs: code segment
   • ds: data segment
   • ss: stack segment
   • es, fs, gs: aribtrary segments

  ef: flags

  Apparently, recent x86 models feature a *thermal status register*. 

  { Segment registers

    An instruction that refers to a memory address implicitly uses a *segment register*.
    For example, a jump instruction uses `cs`, a push instruction uses `ss`.

    Most segment registers can be assigned a value with the `mov` instruction. However `cs` can only be assigned with `jmp` and `call`.

  }
  { x86_64

    The registers were extended to 64 bits: `rax` … `rdx`, `rsp` etc.

    General purpose registers were added: `r8` … `r15`. The lower 32/16/8 bits of these registers are referred to as
    `rXd`, `rXw` and `rXb`.

  }
  { Clobber registers

    With respect to an API (such as the → Windows/development/WinAPI[WinAPI]), registers that can be overwritten in a function of this API are called *clobber registers*.

    In the 32-bit WinAPI, the clobber registers are `eax`, `ecx` and `edx`.
    In the 64-bit WinAPI, all registers are clobber registers except `rbp`, `rbx`, `rdi`, `rsi`, `r12`, `r13`, `r14` and `r15`.

  }

}
{ Instructions

  Instructions have one to three operands, most often two:
code {
not  eax
add  eax, ebx
imul eax, edx, 64
code }

}
{ mov

  Apparently, there is no instruction to directly move data from one memory location to another. It always needs to go via a register.

  `cs`, `eip` and `ip` cannot be the destination.

}
{ leave

  `leave` is apparently equivalent to
code {
mov esp, ebp
pop ebp
code }

}
{ Memory reference (pointers)

code {
add [esp], eax ; add value of eax to value of memory pointed at by esp (top of the stack).
code }

}
{ div / idiv

Results stored in eax and edx (rest of division)

code {
mov eax, 42 ; load dividend
mov ecx,  5 ; load divisor
div ecx     ;

code }

}
{ Jump instructions (branching)

  A branching instruction changes the `eip` (instruction pointer) register if the given conditions are met.

  The `call` instruction jumps uncoditionally.
  -
  It stores the `eip` on the stack so that the callee can return to the caller.


}
{ Stack operations

  `push` decrements(!) the stack pointer.

}
{ Sections

  Sections group portions of code and data which have similar purpose or should have the same memory permissions.

  Common names:
    • `.text`: code, never to be paged out.
    • `.data`: read/write (global variables)
    • `.rdata`: rean only data (e.g. strings)
    • `.bss`: block storage start (or block started by symbol). Uninitialized data (only size of objects is specified). The .bss section seems to be merged into the .data section by the linker. Since it contains unintialized data, it helps to reduce the size of the object file and is »expanded« into memory when the executable is loaded.
    • `.reloc`: relocation information, used to modify addresses.
    • `.idata`: import address table. (Seems to be merged into with .text or .rdata).
    • `.edata`: export information
    • `.rsrc`: ressources
    • `PAGE*`: pagable code. Apparently mainly used for → Linux/kernel/drivers[kernel drivers].

   Unneeded seections can be disposed of with `strip`.

}
{ Data for operands

  The data for an operand can be stored
    • in an immediate (const value?)
    • register
    • memory location

   The address of a memory location can be calculated by `base + index*scale + displacement`.
   -
   base: `e{a,b,c,d}x`, `e{s,b}p`, `e{s,d}i`
   -
   index: `e{a,b,c,d}x`, `ebp`, `e{s,d}i`
   -
   scale: 1, 2, 4 or 8
   -
   displacement: 0, 8, 16 or 32 bit

   Intel syntax: `[base + index*scale + disp]`
   -
   AT&T syntax: `disp(base, index, scale)`.

}
{ WinREPL

  → https://github.com/zerosum0x0/WinREPL[WinREPL] is a "read-eval-print loop" shell on Windows that is useful for testing/learning x86 and x64 assembly.

}
{ Misc

  Setting a register to zero (clearing it):
code {
xor eax, eax
code }

  Clear three registers in four bytes:
code {
xor ebx, ebx
mul ebx
code }


}
{ Assemblers for x86

  → development/languages/C-C-plus-plus/GCC/as[gas]
 
  nasm

  yasm (which apperently is modelled after nasm)

  HLA: *High Level Assembler*, uses a high level language like syntax for declarations of functions and procedure calls and allows for control structures (`if`, `while` …).
  -
  As high level assembler, it requires a (real) low level assembler such as `as` or `masm`.

}
{ First instruction of an x86 #x86-first-instruction

  An x86 begins execution with the instruction stored in  `ffff:fff0`, aka *reset vector*.

  Apparently, there is a jump to the → hardware/BIOS[BIOS] start routine:
code {
ljmp $0xf000, $0xe05b         ;  or $0xffff ????
code }

}

sa:

  → development/languages/assembler/x86/memory-management[Memory management]

  → development/languages/assembler
