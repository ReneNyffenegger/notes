$ Assember (x86)

Since the x86 has evolved over three decades during whicht it had to respond to different »market forces« while maintaining *backward compatiblity*, the x86 assembly language is charged with an immense legacy:
  • 16 bit real mode
  • real mode within *virtual 8068 mode*
  • protected mode (16 or 32 bits)
  • enhanced mode (64 bit)

{ Registers

  eax, ebx, ecx, edx: 32 bit general purpose register (GPR)
  -
  ah, bh, ch, dh: Upper 16 bits of respective GPRs
  -
  al, bl, cl, dl: Lower 16 bits of respective GPRs
  -
  64 Bit version like 32 bit, but with RAX, RBX …
  
  eax has special semantic for arithmic functions.
  -
  ecx has special semantic for looping functions.j
  
  esp: stack pointer
  -
  ebp: basepointer
  
  esi: source for string operations
  
  edi: destination for string operations

  eip: intstruction pointer

  
  cs: code segment
  -
  ds: data segment
  -
  ss: stack segment
  -
  es, fs, gs: aribtrary segments

  ef: flags

  Apparently, recent x86 models feature a *thermal status register*. 

}
{ Instructions

  Instructions have one to three operands, most often two:
code {
not  eax
add  eax, ebx
imul eax, edx, 64
code }

}
{ Memory reference (pointers)

code {
add [esp], eax ; add value of eax to value of memory pointed at by esp (top of the stack).
code }

}
{ div / idiv

Results stored in eax and edx (rest of division)

code {
mov eax, 42 ; load dividend
mov ecx,  5 ; load divisor
div ecx     ;

code }

}
{ Jump instructions (branching)

  A branching instruction changes the `eip` (instruction pointer) register if the given conditions are met.

  The `call` instruction jumps uncoditionally.
  -
  It stores the `eip` on the stack so that the callee can return to the caller.


}
{ Stack operations

  `push` decrements(!) the stack pointer.

}
{ Misc

  Setting a register to zero (clearing it):
code {
xor eax, eax
code }

  Clear three registers in four bytes:
code {
xor ebx, ebx
mul ebx
code }

}
