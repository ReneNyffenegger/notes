
The name Lisp, which originally was spelled with upper case letters (LISP), derives from *LISt Processor*.
-
The source code of a Lisp program consists of lists.

In Lisp, everything is either
  • an atom, or
  • a list

A list contains atoms or other lists. These elements are put within parenthesis and separated with commas.

Atoms are literals like `42`, `"Hello World"` or symbols (names of variables or functions).

A *symbol* is a string of (latin?) letters and digits.

Unless instructed otherwise, a list triggers a function call, the first argument being the name of the function.

{ S-expressions and lists

 *S-expression* stands for *symbolic expression* and is sometimes abbreviated as *sexpr*.

  An S-expression is either
    • an *atom*, or
    • `(x . y)` where both `x` and `y` are S-expressions.


  A *list* is similarly defined as
    • an empty list (denoted as `()`), or
    • a *cons cell* that consists of two elements, both of which are lists.
  

 `(a b c)` is just a short hand notation for `(a . (b . (z . NIL)))`

  A list may contain code or → development/Data.

 `NIL` is the special end-of-list object, sometimes also expressed as `()`. (In *Scheme*, `NIL` seems to be represented as `nil`).

  See also *M-expressions* which stands for meta-expression.

  { NIL and () is the same object

code {
* (eq '() 'nil)
T
code }

  }

}
{ cons (data structure)

  A *cons* is a data structure that contains two values.

  The cons' first value is its *car*, the second value its *cdr*).

}
{ cons (function)

 `(cons A B)` is the function to create a *cons* (denoted with the S-expression `(x . y)`?).
code {
> (cons 1 2)
(1 . 2)
code }

}
{ car / cdr (functions)

  `car` evaluates to the first element in a list.

code {
> (car (cons (cons 1 2) (cons 3 4)))
(1 . 2)
code}

 `cdr` evaluates to the second element in a list (in the liturature typically referred to as «the rest»)
code {
> (cdr (cons (cons 1 2) (cons (cons 3 4) 5)))
((3 . 4) . 5)
code }

}
{ list (data structure)

  A *cons* is also a *list* if its *cdr* is
    • `nil` or
    •  a list

  { Examples of lists

    The cdr is `nil`:
code {
* (cons 3 nil)
(3)
code }

  The cdr of the outer cons is a list (as per previous example):
code {
* (cons 2 (cons 3 nil))
(2 3)
code }

  Because the definition of a list is recursive, this can be extended ad infinitum: 
code {
* (cons 1 (cons 2 (cons 3 nil)))
(1 2 3)
code }

  }
}
{ (list …)

 `list` is the function to create lists
code {
* (list 1 2 3 4 5)
(1 2 3 4 5)
code }

  The same list can also be created with a sequence of `(cons…)` functions. Note the `nil` in the last `(cons 5 nil)`:
code {
* (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
(1 2 3 4 5)
code }

}
{ Representing cons

  A cons is represented with with a pair of parentheses that contains its values, that are themselves separated by a dot.

  A simple cons:
code {
* (cons 1 2)
(1 . 2)
code }

  A cons whose car is a cons:
code {
* (cons (cons 1 2) 3)
((1 . 2) . 3)
code }

  The dot and the parenthesis around the cdr are omitted when its *cdr* is
    • a cons-cell, or
    • `nil`

  There is no such rule that is dependent on cons' car.

  There are nine combination how cons-cell can be constructed:
  { atom | atom

code {
> (cons 1 2)
(1 . 2)
code }

  }
  { atom | cons

code {
> (cons 1 (cons 2 3))
(1 2 . 3)
code }

  }
  { atom | nil

code {
> (cons 1 nil)
(1)
code }

  }
  { cons | atom

code {
> (cons (cons 1 2) 3)
((1 . 2) . 3)
code }

  }
  { cons | cons

code {
> (cons (cons 1 2) (cons 3 4))
((1 . 2) 3 . 4)
code }

  }
  { cons | nil

code {
> (cons (cons 1 2) nil)
((1 . 2))
code }

  }
  { nil | atom

code {
> (cons nil 1)
(() . 1)
code }

  }
  { nil | cons

code {
> (cons nil (cons 1 2))
(() 1 . 2)
code }

  }
  { nil | nil

code {
> (cons nil nil)
(())
code }

  }
}
{ (cadr X)

`(cadr X)` is an abbreviation («syntactic sugar) for `(car (cdr X))`:
code {
* (car (cdr (list 1 2 3 4)))
2
code }

  Same same, but shorter:
code {
* (cadr (list 1 2 3 4))
2
code }

}
{ Quoting lists

  In order to prevent the evaluation of a list, the list must be quoted. This is possible with either a single apostrophe, a backtick or the pseudo function `quote`:
code {
* (+ 1 2 3)
6

* `(+ 1 2 3)
(+ 1 2 3)

* '(+ 1 2 3)
(+ 1 2 3)

* (quote (+ 1 2 3))
(+ 1 2 3)
code }

}
{ quote, function

? `'frm` is identical to `(quote frm)`

? `#'fn` is identical to `(function fn)`


}
{ lambda

code {
> (define twice
    (lambda (x) (* 2 x))
  )
> (twice 21)
42
code }

  Anonymous use of a lambda:
code {
> ( 
    (lambda (x)  (* 3 x))
    14
  )
42
code }

  Because a function that is defined with a lambda-expression has no name, this function cannot refer to itself.
  -
  Hence, `lambda` cannot be used to create recursive functions.

}
{ Applying functions to elements in a list

  Functions that apply a function to the elements in a list include
    • `apply`
    • `mapcar`

}
{ mapcar

  Apply a function to each element of a list. Note that the name of the function in `(mapcar 'twice …)` is quoted. Without quoting it, the interpreter would throw an error.
code {
* (defun twice (x) (* x 2))
* (mapcar 'twice '(2 5 3))
(4 10 6)
code }

}
{ Sequential evaluation

code {
(begin
   (define X 6)
   (define Y 7)
   (* X Y)
)
code }

}
{ setq

 `setq` (a special operator) is the *simple variable assignment statement*.
  -
  It returns the the last assigned value.

code {
(defvar a)
(defvar b)
(defvar c)


(setq        ; Assign
   a    6    ; 6 to a
   b    7    ; 7 to b
   c (* a b) ; 6*7 to c
)

(print c) ; 13
code }


}
{ define vs let vs setq …

 `let` creates a new lexical scope

 `setq` assigns a value to an existing variable.

  Then, there is also `let*` and `letrec`.

  What is `define` doing, anyway?

}
{ TODO

  { define vs defun

   `define` is a function that is available in Scheme but not in Common Lisp.
    -
   `defun` is a function that is available in Common Lisp, but not in scheme.

    Scheme:
code {
> (define (twice x) (* x 2))
> (twice 2)
4
code }

   Common Lisp (sbcl)
code {
* (defun twice (x) (* x 2))
* (twice 2)
code }

  }
  { Variables

    Common Lisp has two types of variables:
      • Ordinary variables, used to name *data objects*
      • Function names, used to name *defined functions*, *macros* and *special operators*

    A Function name is either
      • a symbol, or
      • a list with two elements whose first element is the symbol `setf` and whose second element is a symbol.

    { Accessing und updating variables

      The dynamic value of a variable can be accessed and updated like so:
      table { lll
         ~Accessing~ ☰ ~Updating~ ☰ ~Updating using setf~
         `sm` ☰ `(setq sm new-value)` ☰ `(setf sm new-value)`
         `(car ls)` ☰ `(rplaca ls new-value)` ☰ `(setf (car ls) new-value)`
         `(symbol-value sm)` ☰ `(set sm new-value)` ☰ `(setf (symbol-value sm) new-value)`
      table }

      Thus, having `setf` makes `setq`, `rplaca` and `set` redundant.

    }

  }
  { macro-function

   `macro-function` determines if a given symbol is the name of a macro.

code {
* (if (macro-function 'if    )     "if is a macro"     "if is not a macro")
"if is not a macro"

* (if (macro-function 'lambda) "lambda is a macro" "lambda is not a macro")
"lambda is a macro"
code }

  }
  { Special operators

    table { ll

    `block` ☰ Like `progn` but with the possibility to bail out with `return` or `return-from`. See also `do` and `prog`.
    `catch` ☰ See also `throw`
    `declare` ☰
    `eval-when` ☰
    `flet` ☰ Define locally named functions. Compare with `let`
    `function` ☰
    `go` ☰
    `if` ☰
    `labels` ☰
    `let` ☰ Execute a series of forms with specified variables bound to the specified values. Compare with `progn` and `flet`.
    `let*` ☰ Like `let` but variables are bound in sequence.
    `load-time-value` ☰
    `locally` ☰
    `macrolet` ☰
    `multiple-value-call` ☰
    `multiple-value-prog1` ☰
    `progn` ☰ Evaluate forms in a sequence (think `{ … }` in C. Compare with the `prog1` macro, and the `let` and `block` special operators.
    `progv` ☰ Usefule when writing interpreters for languages embedded in Lisp.
    `quote` ☰
    `return-from` ☰ See also the macro `return`.
    `setq` ☰ The simple variable assignment statement.
    `symbol-macrolet` ☰
    `tagbody` ☰
    `the` ☰
    `throw` ☰ See also `catch`
    `unwind-protect` ☰

    table }
  
    What about:
      • `and`, `or`
      • `cond`
      • `defconstant`
      • `defparameter`
      • `defun` (whose purpose is to define a named function)
      • `defvar` (The recommended way to declare the use of a special variable in a program)
      • `do`
      • `eval-when`
      • `go`
      • `multiple-value-bind`
      • `multiple-value-call`
      • `multiple-value-list`
      • `multiple-value-prog1`
      • `multiple-value-setq`
      • `prog*` (which is to `prog` as `let*` is to `let`)
      • `sample-special-form`
      • `tagbody`
      • `with-open-file`

    See also `special-operator-p` which determines if a symbol globally names a special operator.


  }
  { Read-eval-print loop (REPL

    The REPL is typically used to interact with the Lisp interpreter:
      • Read a *form* from an input-source (file, terminal …)
      • Evaluate the form
      • Print the value to an output sink (terminal, screen, file …)

  }
  { macroexpand / macroexpand-1

    …

  }
  { setf

    By convention, any function named `(setf fn)` should return its first argument as its only value, in order to preserve the specification that setf returns.  its *new value*.

  }
  { function

code {
* (defun twice (x) (* 2 x) )
* (function twice)
#<FUNCTION TWICE>

* #'TWICE
#<FUNCTION TWICE>
code }

code {
* (function (lambda (x) (* 3 x)))
#<FUNCTION (LAMBDA (X)) {52A4ADDB}>
code }

  }
  { function-lambda-expression (Recover the source of a defined function)
  
code {
* (defun fn (a b) (+ a b))
* (function-lambda-expression #'fn)
(LAMBDA (A B) (BLOCK FN (+ A B)))
T
FN

* (function-lambda-expression #'function-lambda-expression)
NIL
T
FUNCTION-LAMBDA-EXPRESSION

* (function-lambda-expression #'does-not-exist)
… error …
code }

  }
  { Equality predicates

    table { ll
      `eq` ☰
      `eql` ☰
      `equal` ☰
      `equalp` ☰ Like `equal` but ignores type differences. The most general function of all.
    table }

code {
* (equalp 5 5.0)
T

* (equal 5 5.0)
NIL
code }

  }
  { typep, subtypep, type-of

   `(type-of obj)` never returns `nil` because each object has a type.

   `(typep obj (type-of obj)` always returns `t`.

code {
* (type-of ())
NULL

* (type-of '())
NULL

* (type-of 'NIL)
NULL

* (type-of NIL)
NULL

* (type-of T)
BOOLEAN

* (type-of '(1 2 3))
CONS

* (type-of 42)
(INTEGER 0 4611686018427387903)

* (type-of 42.99)
SINGLE-FLOAT

* (type-of 42.99L0)
DOUBLE-FLOAT

* (type-of "42.99")
(SIMPLE-ARRAY CHARACTER (5))

* (type-of #'type-of)
COMPILED-FUNCTION

* (type-of (type-of NIL))
SYMBOL

* (type-of #\c)
STANDARD-CHAR

* (type-of (make-array 5))
(SIMPLE-VECTOR 5)
code }

code {
* (type-of *standard-input*)
SYNONYM-STREAM

* (type-of '*standard-input*)
SYMBOL
code }

code {
* (typep '(a b c) 'cons)
T

* (typep 42 'cons)
NIL
code }

  42 is both an integer *and* and atom.
code {
* (typep 42 'integer)
T

* (typep 42 'atom)
T 
code }

  Double float vs single float:
code {
* (typep 42.99L0 'double-float)
T

* (typep 42.99L0 'single-float)
NIL
code }

code {
* (type-of (subtypep 'long-float 'float))
BOOLEAN
code }

code {
* (defvar NUM)
NUM

(setq NUM 42)
42

* (type-of NUM)
(INTEGER 0 4611686018427387903)

* (type-of 'NUM)
SYMBOL
code }

code {
* (subtypep 'float 'long-float)
NIL
T

* (subtypep 'long-float 'float)
T
T
code }

    See also
      • `defstruct` (which creates new types)
      • `coerce`
      • `satisfies`

  }
  { atom, consp

   `(atom obJ) ≡ (typep obj 'atom) ≡ (not (typep obj 'cons))`

   `(consp obJ) ≡ (typep obj 'cons) ≡ (not (typep obj 'atom))`

code {
* (atom 42)
T

* (atom '(a b c))
NIL
code }

code {
* (consp 42)
NIL

* (consp '(a b c))
T
code }

  `()` is `nil`,so:
code {
* (atom '())
T
code }


  }
  { Printing functions

    table { ll

      `prin1` ☰ Representation of an object. `prin1` is intended to be consumed by `read`, compare with `princ`.
      `print` ☰ Like `prin1` except that the printed representation is preceeded by a newline (see `terpri`) and followed by a space.
      `pprint` ☰ Like `print` except that the trailing space is omitted and the object is printed with the `*print-pretty*` flag set to `nil`. Returns no value.
      `princ` ☰ Like `prin1` except that no escape characters are printed. The output of `princ` is intended to be consumed by humans, compare with `prin1`. `princ` prints a character exactly like `write-char` 
      `write-to-string` ☰
      `prin1-to-string` ☰
      `princ-to-string` ☰
      `write-char` ☰ Writes a character (and returns it)
      `write-string` ☰
      `write-line` ☰ Compare with `read-line`
      `write-sequence` ☰
      `terpri` ☰ Writes a newline to the output stream. Identical in effect to `(write-char #\Newline output-stream)`. Compare with `fresh-line`
      `fresh-line` ☰ LIke `terpri`, but only prints a newline if the stream is not at the start of a line. Returns `T` or `F` accordingly.
      `finish-output` ☰
      `force-output` ☰
      `clear-output` ☰
      `write-byte` ☰

    table }

    { write-char

code {
* (write-char #\c)
c
#\c
code }

    }

    { write
code {
* (write "foo")
"foo"
"foo"

* (write 'foo)
FOO
FOO

* (write 2)
2
2

* (write #'write)
#<FUNCTION WRITE>
#<FUNCTION WRITE>
code }

    }

  }
  { format

    Many `format` opereations are directly or indirectly defined in terms of `prin1` or `princ` which are affected  by the *printer control variables*.

    table { ll

      `~A` ☰ Ascii
      `~S` ☰ S-expression
      `~D` ☰ Decimal
      `~B` ☰ Binary
      `~O` ☰ Octal
      `~X` ☰ Hexadecimal
      `~nR` ☰ With given radix `n`. `~@R` and `~:@R` procuce roman numerals
      `~P` ☰ Plural
      `~C` ☰ Character
      `~F` ☰ Fixed floating point
      `~E` ☰ Exponential floating point
      `~G` ☰ General floating point
      `~$` ☰ Dollars floating point
      `~%` ☰ `#\Newline`. `~n%` prints `n` newlines. See also `terpri`
      `~&` ☰
      `~|` ☰ Page seperator
      `~~` ☰ A tilde
      `~T` ☰ Tabulate
      `~*` ☰ Ignore an argument
      `~?` ☰ Indirection
      `~_` ☰ Conditional new line
      `~W` ☰ Write
      `~I` ☰ Indent
      `~(str~)` ☰ Case conversion

    table }

    `~` can be followed immediately with a «real» newline.

    There is also `~[str0 ~;str1 ~;...~;strn~` for conditional expressions (and of course *even more*).

    Common Lisp ed 2, p. 909: All of the existing printing functions (`write`, `prin1`, `print`, `princ`, `pprint`, `write-to-string`, `prin1-to-string`, `princ-to-string`, the `~S` and `~A` format operations, and the
    `~B`, `~D`, `~E`, `~F`, `~G`, `~$`, `~O`, `~R`, and `~X` format operations when they encounter a non-numeric value) are required to be changed to go through the `print-object` generic function

  }
  { defstruct

code {
* (defstruct xyz  num txt)
XYZ
code }

  Behind the scenes, the macro `defstruct` created the function `make-xyz`:
code {
* (defvar obj)
OBJ

* (setf obj (make-xyz :num 42 :txt "hello world"))
#S(XYZ :NUM 42 :TXT "hello world")
code }

  The macro also created the «accessor» functions `xyz-num` and `xyz-txt`:
code {
* (xyz-num obj)
42

* (xyz-txt obj)
"hello world"
code }

  The macro also created the «type» `xyz`:
code {
* (type-of obj)
XYZ

* (typep obj 'xyz)
T

* (xyz-p obj)
T
code }

  … And also a «copier function»:
code {
* (defvar copy-of-obj)
COPY-OF-OBJ

* (setf copy-of-obj (copy-xyz obj))
#S(XYZ :NUM 42 :TXT "hello world")
code }
  
  Modify struct-objects with `setf`:
code {
* (setf (xyz-num copy-of-obj) 99)
99

* copy-of-obj
#S(XYZ :NUM 99 :TXT "hello world")

* obj
#S(XYZ :NUM 42 :TXT "hello world")
code }

  See also `defclass`.

  }
  { loop

code {
* (loop for i from 1 to 5 collect i)
(1 2 3 4 5)
code }

  }
  { make-array

code {
* (make-array 5)
#(0 0 0 0 0)

* (make-array '(2 3))
#2A((0 0 0) (0 0 0))

* (make-array 5 :initial-contents '(3 2 5 4 1))
#(3 2 5 4 1)
code }

   { :element-type

code {
* (make-array 5 :element-type 'single-float)
#(0.0 0.0 0.0 0.0 0.0)
code }

     See also `subtypep`.

   }

  }
  { &optional

    In a parameter list (of a functino?), all arguments on the right side of `&optional` are optional

code {
* (defun greet (name &optional (greeting "Hello"))
    (format t "~a, ~a!~%" greeting name))

* (greet 'Rene)
Hello, RENE!
NIL
* (greet 'Rene "hi")
hi, RENE!
NIL
* (greet "Rene")
Hello, Rene!
NIL
code }

    See also `&rest` and `&key`.

  }
  { read

   `read` is the so-called «Lisp reader»: it reads characters from an input stream and parses them as representations of Lisp objects.

    The behavior of `read` is controled by *readtables*.

   `read &optional input-stream eof-error-p eof-value recursive-p`

   `read` reads in the printed representation of a Lisp object from input-stream, builds a corresponding Lisp object, and returns the object.

?  `read` seems to be associated with the opening paranethesis (which seems to be a macro)

  }
  { describe

code {
* (describe '5)
5
  [fixnum]
code }

code {
* (describe '5.5)
5.5
  [single-float]
code }

code {
* (describe #'describe)
#<FUNCTION DESCRIBE>
  [compiled function]


Lambda-list: (SB-IMPL::OBJECT &OPTIONAL
              (SB-KERNEL:STREAM-DESIGNATOR *STANDARD-OUTPUT*))
Declared type: (FUNCTION (T &OPTIONAL (OR STREAM BOOLEAN))
                (VALUES &OPTIONAL))
Documentation:
  Print a description of OBJECT to STREAM-DESIGNATOR.
Known attributes: unwind, any
Source file: SYS:SRC;CODE;DESCRIBE.LISP
code }

  }
  { inspect

   `inspect` is the interactive version of `describe`

code {
* (format (inspect #'inspect))

The object is a FUNCTION named INSPECT.
0. Lambda-list: (SB-IMPL::OBJECT)
1. Ftype: (FUNCTION (T) (VALUES &OPTIONAL))
code }

code {
* (format (inspect #'inspect))

The object is a FUNCTION named INSPECT.
0. Lambda-list: (SB-IMPL::OBJECT)
1. Ftype: (FUNCTION (T) (VALUES &OPTIONAL))
> (inspect 'inspect)

The object is a SYMBOL.
0. Name: "INSPECT"
1. Package: #<PACKAGE "COMMON-LISP">
2. Value: "unbound"
3. Function: #<FUNCTION INSPECT>
4. Plist: NIL
code }

  }
  { apropos

code {
* (apropos 'print)
code }

  }
  { SBCL

    { Types

      The SBCL compiler treats types differently (with more comprehensive type checking) than most other Lisp compilers. 

    }

    { sb-kernel:get-lisp-obj-address

    In *SBCL*:
code {
* (sb-kernel:get-lisp-obj-address  42 )
84

* (sb-kernel:get-lisp-obj-address "42")
68745230335

* (sb-kernel:get-lisp-obj-address #'sb-kernel:get-lisp-obj-address)
1386184299
code }

    Compare with `describe` and `inspect`

    See also
      • `find-object-by-address`
      • `system:address-of` in *CLISP*.


    }

  }

}


sa:
  Other → development/languages[programming languages] etc.
