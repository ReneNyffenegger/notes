$ Python library: evdev
@ evdev

{ Monitor an input device

  The following command must likely be executed as root:
code {
python -m evdev.evtest
code }

}
{ InputDevice

 `evdev.InputDevice` represents an input device (think `→ Linux/fhs/dev/input/eventX`) from which input events can be read.

  table { ll
    `__init__` ☰
    `path` ☰ The device that the instance is reading from (`→ Linux/fhs/dev/input/eventX`)
    `fd` ☰ Likely a file descriptor
    `info` ☰ An instance of `device.DeviceInfo`
    `name` ☰
    `phys` ☰ A string whose value is something like `isa0060/serio0/input0`
    `uniq` ☰ A string
    `version` ☰ An `int`
    `ff_effects_count` ☰ An `int`
    `capabilities()` ☰
    `input_props` ☰ A `list`
    `leds()` ☰
    `set_led()` ☰
    `__eq__` ☰
    `__ne__` ☰
    `__fspath__` ☰
    `grab`, `ungrab` ☰ Exclusively grab (or release) a device (`EVIOCGRAB`).
    `grab_context` ☰ A → development/languages/Python/objects/context-manager that calls `ungrab()` when the corresponding `with` block is exited.
    `upload_effect` ☰
    `erase_effect` ☰
    `repeat` ☰
    `active_keys()` ☰
    `fn` ☰
    `absinfo` ☰
    `__hash__` ☰
  table}

}
{ UInput #py-evdev-UInput

 `evdev.UInput` …

}
{ events.InputEvent #py-evdev-InputEvent

  Instances of `InputEvent` are returned by `EventIO.read_loop()` and `EventIO.read()`.

  The `evdev.events.InputEvent` resemples the → Linux/kernel/source/include/uapi/linux/input_h#linux-input_event[`struct input_event`] found in `→ Linux/kernel/source/include/uapi/linux/input_h`.

  The module also defines specific subtypes depending on the type of an event (key, abs, rel etc.) (see also the `util.categorize` function and the `event_factory` dictionary).
  -
  Such subclasses include
  table { ll
    `InputEvent` ☰ A generic event
    `KeyEvent` ☰ An event generated by a keyboard or other key-like devices
    `RelEvent` ☰ An event generated by devices with relative movements (like mice)
    `AbsEvent` ☰
  table }

}
{ eventio.EventIO

  Used by → #py-evdev-InputEvent[`evdev.InputEvent`] for reading, by → #py-evdev-UInput[`UInput`] for writing events.

  Methods in this class seem to be:
  table { ll
    `fileno` ☰
    `read_loop` ☰ Indefinitely returns `InputEvent` instances.
    `read_one` ☰ returns an instance of → #py-evdev-InputEvent[`InputEvent`]
    `read` ☰
    `need_write` ☰
    `write_event`, `write` ☰ Injects an event into the input subsystem.
    `close` ☰
  table }

}
{ ecodes #py-evdev-ecodes

  → development/languages/Python/types/dict[Dictionaries] with constants defined in `→ Linux/kernel/source/include/uapi/linux/input-event-codes_h` and `linux/input.h` (more likely `include/uapi/linux/input.h` than `include/linux/input.h` - even though the latter includes the former).

code {
from evdev import ecodes

for ecode in dir(ecodes):
    print(ecode + ': ' + str(type(getattr(ecodes, ecode))))
code }

  { ecodes.EV

code {
from evdev import ecodes

for ev in ecodes.EV:
    print(f"{ecodes.EV[ev]:<14} {ev}")
#
# EV_ABS         3
# EV_CNT         32
# EV_FF          21
# EV_FF_STATUS   23
# EV_KEY         1
# EV_LED         17
# EV_MAX         31
# EV_MSC         4
# EV_PWR         22
# EV_REL         2
# EV_REP         20
# EV_SND         18
# EV_SW          5
# EV_SYN         0
# EV_UINPUT      257
# EV_VERSION     65537
code }

    It seems that the values if `ecodes.EV` can be used to determine the event type:
code {
import evdev
device = evdev.InputDevice('/dev/input/event7')

for event in device.read_loop():
    if   event.type == evdev.ecodes.EV_KEY:
         print(evdev.categorize(event))
    elif event.type == evdev.ecodes.EV_SYN:
         print('SYN event')
    else:
        print('Event type: ' + str(event.type))
code }

  }

}
{ device.DeviceInfo

  table { ll
   `bustype` ☰
   `vendor` ☰
   `product` ☰
   `version` ☰
  table }

  When the instance is printed, it produces a value like `bus: 0011, vendor 0001, product 0001, version abba`.

}
{ util

  Functions offered by `evdev.util` include:
  table { ll
    `list_devices()` ☰ Returns a list of strings each of which is  areadable devices in a given directory (default directory of course is `→ Linux/fhs/dev/input`).
    `is_device` ☰ Checks if a device is a readable and writable → Linux/devices#character-devices[character device].
    `categorize` ☰ Categorizes an event according to its type. This function is somehow related to the `event_factory` dictionary which maps event types to subclasses of → #py-evdev-InputEvent[`InputEvent`].
    `resolve_evcodes` ☰ Resolves event codes and types to their verbose names.
    `resolve_ecodes_dict` ☰
  table }

}

{ Misc

  { Find a device by a given name

    The following snippet uses a nested → development/languages/Python/types/list/comprehension to find a device object of an input device with a given name:
code {
import evdev

devname = 'LITEON Technology USB Multimedia Keyboard'
        # 'AT Translated Set 2 keyboard'

devobjs = [ devobj for devobj  in [ evdev.InputDevice(devpath) 
                   for devpath in evdev.list_devices() ]
              if devobj.name == devname
          ]

if devobjs == []:
   print('no device found')
   quit()

devobj=devobjs[0]

print(devobj)
code }

  }
  { Print named constants of pressed keys

code {
import evdev

devname = 'LITEON Technology USB Multimedia Keyboard'

devobjs = [ devobj for devobj  in [ evdev.InputDevice(devpath) 
                   for devpath in evdev.list_devices() ]
              if devobj.name == devname
          ]

if devobjs == []:
   print('no device found')
   quit()

devobj=devobjs[0]

for ev in devobj.read_loop():
    if ev.type == evdev.ecodes.EV_KEY and ev.value == 1:
       print(evdev.ecodes.KEY[ev.code])
code }

  }

}

sa:

  → development/languages/Python/libraries/evdev/mapper[Mapping my keyboard] with `evdev`.

 `→ Linux/fhs/dev/input/eventX`
