$ Python library: evdev
@ evdev

{ Monitor an input device

  The following command must likely be executed as root:
code {
python -m evdev.evtest
code }

}
{ InputDevice

 `evdev.InputDevice`

}
{ UInput #py-evdev-UInput

 `evdev.UInput` …

}
{ events.InputEvent #py-evdev-InputEvent

  The `evdev.events.InputEvent` resemples the → Linux/kernel/source/include/uapi/linux/input_h#linux-input_event[`struct input_event`] found in `→ Linux/kernel/source/include/uapi/linux/input_h`.

  The module also defines specific subtypes depending on the type of an event (key, abs, rel etc.) (see also the `util.categorize` function and the `event_factory` dictionary).
  -
  Such subclasses include
  table { ll
    `InputEvent` ☰ A generic event
    `KeyEvent` ☰ An event generated by a keyboard or other key-like devices
    `RelEvent` ☰ An event generated devices with relative movements (like mice)
    `AbsEvent` ☰
  table }

}
{ eventio.EventIO

  Used by → #py-evdev-InputEvent[`evdev.InputEvent`] for reading, by → #py-evdev-UInput[`UInput`] for writing events.

  Methods in this class seem to be:
  table { ll
    `fileno` ☰
    `read_loop` ☰ Indefinitely reads `InputEvent` instances.
    `read_one` ☰ Reads an instance of → #py-evdev-InputEvent[`InputEvent`]
    `read` ☰
    `need_write` ☰
    `write_event` ☰ Injects an event into the input subsystem.
  table }

}
{ ecodes #py-evdev-ecodes

  → development/languages/Python/types/dict[Dictionaries] with constants defined in `→ Linux/kernel/source/include/uapi/linux/input-event-codes_h` and `linux/input.h` (more likely `include/uapi/linux/input.h` than `include/linux/input.h` - even though the latter includes the former).

code {
from evdev import ecodes

for ecode in dir(ecodes):
    print(ecode + ': ' + str(type(getattr(ecodes, ecode))))
code }

  { ecodes.EV

code {
from evdev import ecodes

for ev in ecodes.EV:
    print(f"{ecodes.EV[ev]:<14} {ev}")
#
# EV_ABS         3
# EV_CNT         32
# EV_FF          21
# EV_FF_STATUS   23
# EV_KEY         1
# EV_LED         17
# EV_MAX         31
# EV_MSC         4
# EV_PWR         22
# EV_REL         2
# EV_REP         20
# EV_SND         18
# EV_SW          5
# EV_SYN         0
# EV_UINPUT      257
# EV_VERSION     65537
code }

    It seems that the values if `ecodes.EV` can be used to determine the event type:
code {
import evdev
device = evdev.InputDevice('/dev/input/event7')

for event in device.read_loop():
    if   event.type == evdev.ecodes.EV_KEY:
         print(evdev.categorize(event))
    elif event.type == evdev.ecodes.EV_SYN:
         print('SYN event')
    else:
        print('Event type: ' + str(event.type))
code }

  }

}
{ util

  Functions offered by `evdev.util` include:
  table { ll
    `list_devices` ☰ Lists readable devices in a given directory (default directory of course is `→ Linux/fhs/dev/input`)
    `is_device` ☰ Checks if a device is a readable and writeable → Linux/devices#character-devices[character device].
    `categorize` ☰ Categorizes an event according to its type. This function is somehow related to the `event_factory` dictionary which maps event types to subclasses of → #py-evdev-InputEvent[`InputEvent`].
    `resolve_evcodes` ☰ Resolves event codes and types to their verbose names.
    `resolve_ecodes_dict` ☰
  table }

}

sa:
 `→ Linux/fhs/dev/input/eventX`
