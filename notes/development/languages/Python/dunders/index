$ Python: dunders

*Dunders* are names with two leading and two trailing underscords such as `__init__` or `__version__`.

`__aenter__` and `__aexit__` are present in an *asynchronous context manager* (see `async with`).

→ development/languages/Python/dunders/__annotations__[`__annotations__`]

If an → development/languages/Python/objects has a → development/languages/Python/dunders/__bool__[`__bool__`] method, the value that this method returns determines if an object is considered to be `True` or `False` when
→ development/languages/Python/objects/evaluating-in-boolean-context[evaluated in a boolean context].

→ development/languages/Python/dunders/__builtins__[`__builtins__`] contains → development/languages/Python/built-in-functions[built-in functions], exceptions and other objects.

An object that implements → development/languages/Python/dunders/__call__[`__call__`] becomes a → development/languages/Python/objects/callable[callable object].

→ development/languages/Python/dunders/__debug__[`__debug__`]

→ development/languages/Python/dunders/__del__[`__del__()`] is called when an object's → development/languages/Python/objects/reference-counter reaches zero.

→ development/languages/Python/dunders/__dict__[`__dict__`]

→ development/languages/Python/dunders/__dir__[`__dir__()`]

→ development/languages/Python/dunders/__doc__[`__doc__`]

→ development/languages/Python/dunders/__enter__[`__enter__()`]

→ development/languages/Python/dunders/__exit__[`__exit__()`]

→ development/languages/Python/dunders/__file__[`__file__`] corresponds to the pathname where a Python script or → development/languages/Python/module was loaded from.

→ development/languages/Python/dunders/__getattr__[`__getattr__`] is called if a user of an → development/languages/Python/objects tries to access a member of method on that object that does not exist.

? → development/languages/Python/dunders/__getitem__[`__getitem__`]

→ development/languages/Python/dunders/__init__[`__init__`]

→ development/languages/Python/dunders/__init_subclass__/[`__init_subclass__`] is called when a subclass (not an instance) of a → development/languages/Python/class[class] is being created.

Any → development/languages/Python/objects that has an → development/languages/Python/dunders/__iter__[`__iter__()`] method is an → development/languages/Python/iterable.

? → development/languages/Python/dunders/__len__[`__len__`]

→ development/languages/Python/dunders/__loader__[`__loader__`]

→ development/languages/Python/dunders/__lt__[`__lt__`] stands for *less than* and defines how the `<` operator behaves when applied between two → development/languages/Python/objects[objects].

→ development/languages/Python/dunders/__mro__[`__mro__`] stands for → development/languages/Python/class/methods/resolution-order.

→ development/languages/Python/dunders/__next__[`__next__`]

→ development/languages/Python/dunders/__package__[`__package__`]

A → development/languages/Python/module with a → development/languages/Python/dunders/__path__[`__path__`] is considered a *package*.

→ development/languages/Python/dunders/__repr__[`__repr__`]

Using → development/languages/Python/dunders/__reversed__[`__reversed__()`] is a possibility to implement the protocol that is required by the
→ development/languages/Python/built-in-functions/reversed[`reversed()`] built-in function.

→ development/languages/Python/dunders/__setattr__[`__setattr__`]

→ development/languages/Python/dunders/__spec__[`__spec__`]

→ development/languages/Python/dunders/__str__[`__str__`]

→ development/languages/Python/dunders/__weakref__[`__weakref__`]

→ development/languages/Python/dunders/mathematical[Mathematical dunders] such as `__add__`, `__mul__` etc allow to «overload» `+`, `*` etc.


